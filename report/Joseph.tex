\documentclass{article}
\usepackage[left=1in,right=1in,tmargin = 25mm,bmargin = 25mm]{geometry}
\usepackage[left=1in,right=1in]{geometry}
\usepackage{subfiles}
\usepackage{amsmath, amssymb, stmaryrd, verbatim, bbm, mathabx} % math symbols
\usepackage{amsthm} % thm environment
\usepackage{mdframed} % Customizable Boxes
\usepackage{hyperref,nameref,cleveref,enumitem} % for references, hyperlinks
\usepackage[dvipsnames]{xcolor} % Fancy Colours
\usepackage{mathrsfs} % Fancy font
\usepackage{tikz, tikz-cd, float} % Commutative Diagrams
\usepackage{perpage}
\usepackage{parskip} % So that paragraphs look nice
\usepackage{ifthen,xargs} % For defining better commands
\usepackage{anyfontsize}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage{titlesec}
\usepackage{url}
\usepackage{listings}

% % Misc
\newcommand{\brkt}[1]{\left(#1\right)}
\newcommand{\sqbrkt}[1]{\left[#1\right]}
\newcommand{\dash}{\text{-}}
\newcommand{\tdt}{\times \dots \times}

% % Logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\limplies}{\Leftarrow}
\newcommand{\NOT}{\neg\,}
\newcommand{\AND}{\land}
\newcommand{\OR}{\lor}
\newenvironment{forward}{($\implies$)}{}
\newenvironment{backward}{($\limplies$)}{}
% General way of making larger symbols with limits above and below
\makeatletter
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{
      \ifx#1\displaystyle.7\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}% symbol size
  }%
}
\makeatother
\newcommand{\bigforall}[2]{\DOTSB\bigop{\forall}_{#1}^{#2}}
\newcommand{\bigexists}[2]{\DOTSB\bigop{\exists}_{#1}^{#2}}
\newcommand{\bigand}[2]{\DOTSB\bigop{\mbox{\Large$\land$}}_{#1}^{#2}}
\newcommand{\bigor}[2]{\DOTSB\bigop{\mbox{\Large$\lor$}}_{#1}^{#2}}

% % Sets
\DeclareMathOperator{\supp}{supp}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\st}{\,|\,}
\newcommand{\minus}{\setminus}
\newcommand{\subs}{\subseteq}
\newcommand{\ssubs}{\subsetneq}
\DeclareMathOperator{\im}{Im}
\newcommand{\nothing}{\varnothing}
\newcommand\res[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace
  % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|}
  % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

% % Greek
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\varepsilon}
\newcommand{\io}{\iota}
\newcommand{\ka}{\kappa}
\newcommand{\la}{\lambda}
\newcommand{\om}{\omega}
\newcommand{\si}{\sigma}

\newcommand{\Ga}{\Gamma}
\newcommand{\De}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\La}{\Lambda}
\newcommand{\Si}{\Sigma}
\newcommand{\Om}{\Omega}

% % Mathbb
\newcommand{\A}{\mathbb{A}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\U}{\mathbb{U}}

% % Mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\II}{\mathcal{I}}
\newcommand{\JJ}{\mathcal{J}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\newcommand{\RR}{\mathcal{R}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YY}{\mathcal{Y}}
\newcommand{\ZZ}{\mathcal{Z}}

% % Mathfrak
\newcommand{\f}[1]{\mathfrak{#1}}

% % Mathrsfs
\newcommand{\s}[1]{\mathscr{#1}}

% % Category Theory
\newcommand{\obj}[1]{\mathrm{Obj}\left(#1\right)}
\newcommand{\Hom}[3]{\mathrm{Hom}_{#3}(#1, #2)\,}
\newcommand{\mor}[3]{\mathrm{Mor}_{#3}(#1, #2)\,}
\newcommand{\End}[2]{\mathrm{End}_{#2}#1\,}
\newcommand{\aut}[2]{\mathrm{Aut}_{#2}#1\,}
\newcommand{\CAT}{\mathbf{Cat}}
\newcommand{\SET}{\mathbf{Set}}
\newcommand{\TOP}{\mathbf{Top}}
%\newcommand{\GRP}{\mathbf{Grp}}
\newcommand{\RING}{\mathbf{Ring}}
\newcommand{\MOD}[1][R]{#1\text{-}\mathbf{Mod}}
\newcommand{\VEC}[1][K]{#1\text{-}\mathbf{Vec}}
\newcommand{\ALG}[1][R]{#1\text{-}\mathbf{Alg}}
\newcommand{\PSH}[1]{\mathbf{PSh}\brkt{#1}}
\newcommand{\map}[2]{ \yrightarrow[#2][2.5pt]{#1}[-1pt] }
\newcommand{\op}{^{op}}
\newcommand{\darrow}{\downarrow}
\newcommand{\LIM}[2]{\varprojlim_{#2}#1}
\newcommand{\COLIM}[2]{\varinjlim_{#2}#1}
\newcommand{\hookr}{\hookrightarrow}

% % Algebra
\newcommand{\iso}{\cong}
\newcommand{\nsub}{\trianglelefteq}
\newcommand{\id}[1]{\mathbbm{1}_{#1}}
\newcommand{\inv}{^{-1}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}
\DeclareMathOperator{\coker}{Coker}
\DeclareMathOperator{\spec}{Spec}

% % Analysis
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\renewcommand{\check}[1]{\widecheck{#1}}

% % Galois
\newcommand{\Gal}[2]{\mathrm{Gal}_{#1}(#2)}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}
\newcommand{\emb}[3]{\mathrm{Emb}_{#1}(#2, #3)}
\newcommand{\Char}[1]{\mathrm{Char}#1}

% % Model Theory
\newcommand{\intp}[2]{
    \star_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\subintp}[3]{
    {#3}_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\modintp}[2]{#2^\text{\scalebox{0.7}{$#1$}}}
\newcommand{\mmintp}[1]{\modintp{\MM}{#1}}
\newcommand{\nnintp}[1]{\modintp{\NN}{#1}}
\DeclareMathOperator{\const}{constants}
\DeclareMathOperator{\func}{functions}
\DeclareMathOperator{\rel}{relations}
% \newcommand{\term}[1]{{#1}_\mathrm{ter}}
% \newcommand{\tv}[1]{\textrm{tv}_{#1}}
% \newcommand{\struc}[1]{\mathbf{Str}(#1)}
% \newcommand{\form}[1]{{#1}_\mathrm{for}}
% \newcommand{\var}[1]{{#1}_\mathrm{var}}
% \newcommand{\theory}[1]{{#1}_\mathrm{the}}
% \newcommand{\carrier}[1]{{#1}_\mathrm{car}}
% \newcommand{\model}[1]{\vDash_{#1}}
% \newcommand{\nodel}[1]{\nvDash_{#1}}
% \newcommand{\modelsi}{\model{\Si}}
% \newcommand{\nodelsi}{\nvDash_{\Si}}
% \newcommand{\eldiag}[2]{\mathrm{ElDiag}(#1,#2)}
% \newcommand{\atdiag}[2]{\mathrm{AtDiag}(#1,#2)}
% \newcommand{\Theory}{\mathrm{Th}}
% \newcommand{\unisen}[1]{{#1}_\mathrm{uni}}
\newcommand{\lift}[2]{\uparrow_{#1}^{#2}}
\newcommand{\fall}[2]{\downarrow_{#1}^{#2}}
\DeclareMathOperator{\GRP}{GRP}
\newcommand{\RNG}{\mathrm{RNG}}
\newcommand{\ER}{\mathrm{ER}}
\DeclareMathOperator{\FLD}{FLD}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\ZFC}{ZFC}
\DeclareMathOperator{\ACF}{ACF}
\newcommand{\BLN}{\mathrm{BLN}}
\newcommand{\PO}{\mathrm{PO}}
\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\qftp}{qftp}
\DeclareMathOperator{\qf}{qf}
\DeclareMathOperator{\eqzero}{eqzero}
\newcommand{\MR}[2]{\mathrm{MR}^{#1}(#2)}
\DeclareMathOperator{\MD}{MD}
\DeclareMathOperator{\acl}{acl}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\mdeg}{m.deg}
\DeclareMathOperator{\kdim}{k.dim}
\newcommand{\Mod}[1]{EDITTHIS {#1}}
% % Set theory
\DeclareMathOperator{\ord}{Ord}

% % Boolean algebra
\newcommand{\NEG}{\smallsetminus}
\newcommand{\upa}[1]{#1^{\uparrow}}

% % Field theory
\DeclareMathOperator{\tdeg}{t.deg}
\newcommand{\zmo}[2][p]{\Z/#1^{#2}\Z}

%% code from mathabx.sty and mathabx.dcl to get some symbols from mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}

% Arrows with text above and below with adjustable displacement
% (Stolen from Stackexchange)
\newcommandx{\yaHelper}[2][1=\empty]{
\ifthenelse{\equal{#1}{\empty}}
  % no offset
  { \ensuremath{ \scriptstyle{ #2 } } }
  % with offset
  { \raisebox{ #1 }[0pt][0pt]{ \ensuremath{ \scriptstyle{ #2 } } } }
}

\newcommandx{\yrightarrow}[4][1=\empty, 2=\empty, 4=\empty, usedefault=@]{
  \ifthenelse{\equal{#2}{\empty}}
  % there's no text below
  { \xrightarrow{ \protect{ \yaHelper[ #4 ]{ #3 } } } }
  % there's text below
  {
    \xrightarrow[ \protect{ \yaHelper[ #2 ]{ #1 } } ]
    { \protect{ \yaHelper[ #4 ]{ #3 } } }
  }
}

% xcolor
\definecolor{darkgrey}{gray}{0.10}
\definecolor{lightgrey}{gray}{0.30}
\definecolor{slightgrey}{gray}{0.80}
\definecolor{softblue}{RGB}{30,100,200}

% hyperref
\hypersetup{
      colorlinks = true,
      linkcolor = {softblue},
      citecolor = {blue}
}

\newcommand{\link}[1]{\hypertarget{#1}{}}
\newcommand{\linkto}[2]{\hyperlink{#1}{#2}}

% Theorems

% % custom theoremstyles
\newtheoremstyle{definitionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % custom theoremstyles
\newtheoremstyle{propositionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

\newtheoremstyle{exercisestyle}%
{0pt}% above thm
{0pt}% below thm
{\it}% body font
{}% space to indent
{\scshape}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{ (#3)}}

\newtheoremstyle{remarkstyle}%
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\it}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % Theorem environments

\theoremstyle{definitionstyle}
\newmdtheoremenv[
    %skipabove = \baselineskip
    linewidth = 2pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{dfn}{Definition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{prop}{Proposition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{cor}{Corollary}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{lem}{Lemma}


\theoremstyle{exercisestyle}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{ex}{Exercise}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{eg}{Example}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{nttn}{Notation}

\theoremstyle{remarkstyle}
\newtheorem{rmk}{Remark}

% % footnotes
\renewcommand{\thempfootnote}{$\dagger$}
\MakePerPage{footnote}

% % tikzcd diagram
\newenvironment{cd}{
    \begin{figure}[H]
    \centering
    \begin{tikzcd}
}{
    \end{tikzcd}
    \end{figure}
}

% tikzcd
% % Substituting symbols for arrows in tikz comm-diagrams.
\tikzset{
  symbol/.style={
    draw=none,
    every to/.append style={
      edge node={node [sloped, allow upside down, auto=false]{$#1$}}}
  }
}


\titlespacing*{\section}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}

% Syntax highlighting for lean

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.6, 0.3, 0.6}   % light purple
\definecolor{tacticcolor}{rgb}{0.2, 0.2, 0.6}    % dark purple
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.7, 0.2, 0.2}    % blue
\definecolor{sortcolor}{rgb}{0.2, 0.7, 0.7}      % cyan
\definecolor{attributecolor}{RGB}{120,0,0}       % maroon
\definecolor{draculaGrey}{RGB}{25, 27, 15}       % grey

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\begin{document}
\title{Limits in the category of categories}
\author{Joseph Hua}
\maketitle

\section{Introduction}

All of my work is in two files, \texttt{to\_mathlib.lean}
(which contains lemmas that would be useful to have in various places in \texttt{mathlib})
and \texttt{limits.lean}
(which should ideally go in a folder for \texttt{Cat}, the category of categories).
Some of the the content in those files is \textit{not} my own,
and I have pointed this out each time in a comment.

In this project, I show that \texttt{Cat.\{u u\}}, the category of small categories
is complete, where ``small'' in \texttt{lean} is taken to mean
the universe levels (sizes) for objects and morphisms is the same.
I also show that \texttt{Cat.\{v u\}}, the category of all categories
(up to appropriate universe levels) has all finite limits.
Since the category of categories is a bicategory,
and it is rare in practice to work with strict equality of functors,
the ``morally correct'' limits to consider should really be 2-limits,
considering functors up to natural isomorphism.
However, I construct 1-limits, since they exist anyway.
This should deduce the 2-limit case, as equal funtors are trivially naturally isomorphic.

An obvious next step is to show results for colimits, which I have not yet done.

\section{Relevant definitions and results in \texttt{mathlib}}

\begin{dfn}[Diagrams, cones and limits]
  A diagram in a category $\CC$ is simply a functor from some category
  $F : \II \to \CC$, and $\II$ is called the shape.
  Diagrams are not explicitely defined in \texttt{lean},
  as this leads to extra unnecessary definitional equalities.

  % https://q.uiver.app/?q=WzAsNixbNiwwLCJcXG1hdGhjYWx7Rn0gaiJdLFs0LDAsIlxcbWF0aGNhbHtGfSBpIl0sWzAsMCwiaSJdLFsxLDAsImoiXSxbMiwwXSxbMywwXSxbMSwwLCJcXG1hdGhjYWx7Rn0gXFxwaGkiLDIseyJjdXJ2ZSI6M31dLFsxLDAsIlxcbWF0aGNhbHtGfSBcXHBzaSIsMCx7ImN1cnZlIjotM31dLFsyLDMsIlxccGhpIiwyLHsiY3VydmUiOjJ9XSxbMiwzLCJcXHBzaSIsMCx7ImN1cnZlIjotMn1dLFs0LDUsIiIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRvdHRlZCJ9fX1dXQ==
  \[\begin{tikzcd}
  	i & j & {} & {} & {\mathcal{F} i} && {\mathcal{F} j}
  	\arrow["{\mathcal{F} \phi}"', bend right={30}, from=1-5, to=1-7]
  	\arrow["{\mathcal{F} \psi}", bend right={-30}, from=1-5, to=1-7]
  	\arrow["\phi"', bend right={30}, from=1-1, to=1-2]
  	\arrow["\psi", bend right={-30}, from=1-1, to=1-2]
  	\arrow["{\mathcal{F}}", dotted, from=1-3, to=1-4]
  \end{tikzcd}\]
  \[ \text{\small A diagram for equalizers}\]

  A cone over a diagram $F : \JJ \to \CC$ consists of an apex $X$ an object in $\CC$
  and a natural transformation from (the constant functor at) $X$ to $F$.
  This natural transformation captures the data of legs from $X$ into the diagram
  that commute with the maps in the diagram.

  \begin{lstlisting}
    structure cone (F : J ⥤ C) := (X : C) (π : (const J).obj X ⟶ F) \end{lstlisting}

  Here \texttt{lean} recognizes that \texttt{F} is a functor,
  so it infers that the morphism ($\pi$)
  \footnote{Unfortunately the arrows for morphisms (\texttt{\textbackslash hom} $\to$)
    and for functions (\texttt{\textbackslash to} $\to$) look the same.}
  into \texttt{F} should be
  in the functor fategory, i.e. a natural transformation.

    \[\begin{tikzcd}
  	& X \\
  	\\
  	{\mathcal{F} i} && {\mathcal{F} j}
  	\arrow["{\mathcal{F} \phi}"', bend right={30}, from=3-1, to=3-3]
  	\arrow["{\mathcal{F} \psi}", bend right={-30}, from=3-1, to=3-3]
  	\arrow["{\pi \, i}"', from=1-2, to=3-1]
  	\arrow["{\pi \, j}", from=1-2, to=3-3]
  \end{tikzcd}\]
  \[ \text{\small A cone over the equalizer diagram, or a ``fork''}\]

  Finally, the data of a cone $l$ being the limit of a diagram consists of
  \begin{itemize}
    \item (\texttt{lift}) For any cone $c$, a map $\texttt{lift} : c \to l$ in the category $\CC$.
    \item (\texttt{fac}) A proof that \texttt{lift} commutes with everything else in the diagram.
    \item (\texttt{uniq}) Any other map $c \to l$ commuting with everything is equal to \texttt{lift}.
  \end{itemize}

  Put another way, a limit of a diagram is the terminal object when considering
  the cones as a category.

  \begin{lstlisting}
    structure is_limit (t : cone F) :=
    (lift  : Π (s : cone F), s.X ⟶ t.X)
    (fac'  : ∀ (s : cone F) (j : J), lift s ≫ t.π.app j = s.π.app j . obviously)
    (uniq' : ∀ (s : cone F) (m : s.X ⟶ t.X) (w : ∀ j : J, m ≫ t.π.app j = s.π.app j),
    m = lift s . obviously)
  \end{lstlisting}

  Note that \texttt{lift} is data, whereas the others are propositional.
  Also note that \texttt{fac'} and \texttt{uniq'}
  are appended with \texttt{obviously}.
  This means that when we construct a limit, we could only
  supply the \texttt{lift}, and let \texttt{lean} figure the rest out.
  Many of the structures in the category theory library use this
  so that making instances of categories, functors, natural transformations,
  and limits less work.

  \[\begin{tikzcd}
    & c \\
  	& l \\
  	\\
  	{\mathcal{F} i} && {\mathcal{F} j}
  	\arrow["{\mathcal{F} \phi}"', bend right={30}, from=4-1, to=4-3]
  	\arrow["{\mathcal{F} \psi}", bend right={-30}, from=4-1, to=4-3]
  	\arrow[from=1-2, to=4-1]
  	\arrow[from=1-2, to=4-3]
  	\arrow[from=2-2, to=4-1]
  	\arrow[from=2-2, to=4-3]
    \arrow[dashed, from=1-2, to=2-2]
  \end{tikzcd}\]
  \[ \text{\small $l$ is the equalizer of $\FF \phi$ and $\FF \psi$}\]
\end{dfn}

All of the following are results from \texttt{mathlib} that I will be using in my work.
\begin{itemize}
  \item (Categorical) definitions of binary and arbitrary products,
        equalizers, and pullback.
        Browsable \href{https://leanprover-community.github.io/mathlib_docs/category_theory/limits/shapes/products.html}{here}.
  \item A proof that categories with products and equalizers has all small limits.
        A proof that categories with finite products and equalizers is complete.
        A proof that categories with binary products and terminal objects has finite products.
        Browsable \href{https://leanprover-community.github.io/mathlib_docs/category_theory/limits/constructions/limits_of_products_and_equalizers.html}{here}.
  \item The product of categories (as a category, \textit{not} as an object in \texttt{Cat.\{v u\}}).
        Browsable \href{https://leanprover-community.github.io/mathlib_docs/category_theory/pi/basic.html}{here}.
  \item The binary product of categories (as a category, \textit{not} as an object in \texttt{Cat.\{v u\}}).
        Browsable \href{https://leanprover-community.github.io/mathlib_docs/category_theory/products/basic.html}{here}.
\end{itemize}

\section{The process of giving a limit}

In this section I walk through the general process of giving a limit,
by following my work on binary products.

We begin by giving the object in the category of categories
that we are interested in constructing.
An object in the category of categories consists
of two pieces of data, $\al$ the underlying type,
and \texttt{str} an \texttt{instance} of $\al$ as a category.
The underlying type of the product is simply of product
of the underlying types of \texttt{C} and \texttt{D}.

\begin{lstlisting}
def prod (C D : Cat.{v u}) : Cat.{v u} := { α := (C.α × D.α) } \end{lstlisting}

The second piece of data is given the parameter \texttt{obviously},
so we need not specify it:
the library already has \href{https://leanprover-community.github.io/mathlib_docs/category_theory/products/basic.html}{an \texttt{instance}}
of this type as a category.

We promote this to a cone, by defining the natural transformation from
the constant functor at \texttt{prod} to the diagram.
The diagram in question is called \texttt{pair} and its shape
(a category with just two objects with no morphisms) is (a type that looks exactly like) \texttt{Bool}.
A \texttt{mathlib} lemma \texttt{map\_pair} (specialized to our use case) that says to make a
natural transformation into a \texttt{Bool} shaped diagram,
it suffices to just give a map into each of the two objects in the diagram.
Hence we have a slick definition

\begin{lstlisting}
def cone (C D : Cat.{v u}) : cone (pair C D) :=
{ X := prod C D,
  π := map_pair (fst _ _) (snd _ _) } \end{lstlisting}

We intend for this cone to be the limit.
Which consists of a \texttt{lift}, \texttt{fac}torizations through the \texttt{lift},
and \texttt{uniq}ness of the lift.
Constructing the lift generally amounts to constructing maps for objects and morphisms
by destructing the definition of the limit cone.
In this particular case, since the limit cone is a product of categories,
to make objects and morphisms in it we need to give pairs of objects
and morphisms from each category.
Since cones over this diagram only really consist of functors from the apex
into \texttt{C} and \texttt{D}, giving the \texttt{lift} is a corollary of this definition:

\begin{lstlisting}
def lift (f : E ⟶ C) (g : E ⟶ D) : (E ⟶ prod C D) :=
{ obj := λ z, ⟨ f.obj z , g.obj z ⟩,
  map := λ _ _ h, ⟨ f.map h , g.map h ⟩ }\end{lstlisting}

The remaining two parts of this construction involve proving an equality bewteen two functors,
which deserves some interesting design decisions.
We leave this discussion to the next section.

\section{Equality between functors}

\subsection{\texttt{heq}}

In the introduction it was mentioned that strict equality between
functors was not ``morally correct''.
This is exemplified when we try to prove such an equality.

Naively, extensionality for functors should say two functors $F, G : \CC \to \DD$
are equal if and only if they are equal on objects and on morphisms.
However, type theory complicates this issue for morphisms.
If $x$ and $y$ are objects in $\CC$ and we have proofs that $F x = G x$ and $F y = G y$,
it doesn't make sense to ask given $f : x \to y$ whether $F f = G f$,
because $F f : F x \to F y$ and $G f : G x \to G y$ are terms of types that are not definitionally equal.

The obvious workaround to this issue is to instead ask for a commutative square
where the sides are given by the equalities we have (equal objects are certainly isomorphic).
\[\begin{tikzcd}
	{F x} & {F y} \\
	Gx & Gy
	\arrow["{F f}", from=1-1, to=1-2]
	\arrow["{\texttt{eq\_to\_hom}}"', from=1-1, to=2-1]
	\arrow["Gf"', from=2-1, to=2-2]
	\arrow["{\texttt{eq\_to\_hom}}"', from=2-2, to=1-2]
\end{tikzcd}\]
Whilst this method works - I used it in my first round of proofs,
it can be improved with a clever trick.

Instead of considering strict equality ($=$) on morphisms,
Xu Junyan on Zulip suggested using \texttt{heq}uality ($==$) instead.
This different version of equality is also a proposition whose only
proof is \texttt{refl}
(that the two terms are definitionally the same - in particular they are of the same type),
but this question can be asked even when their ambient types are different.
Hence in the above example I could simply write $F f == G f$,
though I would not be able to prove it until I make the two sides
definitionally equal.

\begin{lstlisting}
inductive heq {α : Sort u} (a : α) : Π {β : Sort u}, β → Prop
| refl [] : heq a\end{lstlisting}

The benefit of this definition is that one doesn't need to deal with the
extra compositions the original workaround introduces.
In the end whatever types we are working with should be rewritten to be definitionally equal
anyway, so it is more straight forward to first imagine that they are equal,
and realise that our imagination was correct later on.

\subsection{The simplest case}
I will list a few of methods I used to show that two functors are equal.

The simplest case: after appropriate definitional simplification
the functors are definitionally equal on objects and morphisms.

A useful result from the library \texttt{functor.hext}
says that two functors are equal if they are equal on objects and
\texttt{heq}ual on morphisms.
In this situation, applying \texttt{functor.hext} works well.
The following is an example of this (for arbitrary products).
The \texttt{lift} is defined \textit{so that} when it is
destructed via composition with the legs of the cone it returns the right side.

\begin{lstlisting}
lemma fac (c : limits.cone F) (i : discrete I) :
  lift c ≫ (cone F).π.app i = c.π.app i :=
functor.hext (λ _, rfl) (λ _ _ _, heq_of_eq rfl) \end{lstlisting}

\subsection{Factoring through the lift}

When one side of the equality has data but the other does not,
we might need to introduce data on the side without.
Here is an example (for equalizers):

\begin{lstlisting}
lemma uniq (c : category_theory.limits.fork F G) (m : c.X ⟶ (fork F G).X)
  (h : ∀ (j : walking_parallel_pair), m ≫ (fork F G).π.app j = c.π.app j) :
  m = is_limit_fork.lift c :=
by { rw equalizer.self_eq_lift m, congr, exact h walking_parallel_pair.zero } \end{lstlisting}

The first rewrite refactors the map \texttt{m} into the limit as a lift of itself
composed with the maps into the diagram.
This introduces data on the left,
putting \texttt{m} into the same form as the right side
(after unfolding what \texttt{is\_limit\_fork.lift} is).

\subsection{Explicitely using the underlying type}

To show that legs of any cone factor through the binary product \texttt{lift},
I cased on the object in the shape for which I am concerned.
This is basically induction on \texttt{Bool},
and the resulting cases are fairly trivial.

\begin{lstlisting}
lemma fac (c : limits.cone (pair C D)) (j : walking_pair) :
  lift c ≫ (cone C D).π.app j = c.π.app j :=
walking_pair.cases_on j (lift_fst _) (lift_snd _)\end{lstlisting}

\section{Equalizers with \texttt{heq}}

My definition of the equalizers of two functors
$F, G : \CC \to \DD$ takes the underlying type to be a
subtype of objects $x$ in the source category $\CC$ such that $F x = G x$.
The morphisms are taken to be the subtype of morphisms $f$ in
each hom set such that $F f == G f$.
The immediate (and so far only; the rest was straight-forward)
issue that arises from using \texttt{heq} is composition in this category:
if $f$ and $g$ are composable morphisms in $\CC$ such that
$F f == G f$ and $F g == G g$, do we have that $F (f \gg g) == G (f \gg g)$?
This fact is not immediately obvious.
To prove this I would like to rewrite the first \texttt{heq}uality.
Since $F f$ is not a variable,
and induction/cases on an equality requires that the first term is a variable,
we cannot case on the proof of $F f == G f$.
One solution to this is generalizing the appropriate variables,
using the \texttt{generalize\_hyp} tactic, given here (due to Xu Junyan).
My explanations are in comments:

\begin{lstlisting}
lemma map_comp_heq (hx : F.obj x = G.obj x) (hy : F.obj y = G.obj y) (hz : F.obj z = G.obj z)
  (hf : F.map f == G.map f) (hg : F.map g == G.map g) :
  F.map (f ≫ g) == G.map (f ≫ g) :=
begin
  rw [F.map_comp, G.map_comp],
  -- cannot case directly on hf, since F.map f is not a variable -> generalize F.map f
  generalize_hyp : F.map f = Ff at ⊢ hf, generalize_hyp : G.map f = Gf at ⊢ hf,
  generalize_hyp : F.map g = Fg at ⊢ hg, generalize_hyp : G.map g = Gg at ⊢ hg,
  -- however, still cannot case on hf, since the types on the left and right are not definitionally equal
  -- To make them definitionally equal, must case on x.2 y.2 z.2
  -- Similarly, to case on x.2 and z.2 must generalize F.obj x, F.obj y, F.obj z
  generalize_hyp : F.obj x = Fx at ⊢ Ff Gf hx,
  generalize_hyp : F.obj y = Fy at ⊢ Fg Ff hy,
  generalize_hyp : F.obj z = Fz at ⊢ Fg Gg hz,
  -- now able to substitute -> all definitionally equal -> cases on hf hg
  subst hx, subst hy, subst hz, cases hf, cases hg,
  exact heq_of_eq rfl,
end \end{lstlisting}

However, I was then informed that the tactic \texttt{congr'}
(but not \texttt{congr}) does almost all of the work.

\begin{lstlisting}
  lemma map_comp_heq (hx : F.obj x = G.obj x) (hy : F.obj y = G.obj y) (hz : F.obj z = G.obj z)
  (hf : F.map f == G.map f) (hg : F.map g == G.map g) :
  F.map (f ≫ g) == G.map (f ≫ g) :=
  by { rw [F.map_comp, G.map_comp], congr' } \end{lstlisting}

If I understand correctly,
this is because \texttt{congr} has the tools for casing on the equalities,
but ``agreessively'' first checks for syntactic similarities,
resulting in goals such as $F = G$, which cannot be proven.
On the other hand \texttt{congr'} first tries to apply
equalities in the hypothesis, and succeeds.

\section{Universe levels}

As this is work on category theory in \texttt{lean},
universe levels deserve attention.
The first detail is sensible, and not a \texttt{lean} specific issue -
that \texttt{Cat} needs to be a small category to be closed under arbitrary limits.
The second was a design issue related to terminal objects.

\subsection{Arbitrary products}

Suppose that \texttt{Cat.\{v u\}} (not small) in general had all arbitrary limits.
Then in particular \texttt{Cat.\{v u\}} would be closed under morphism sized products
(this is the definition of having all limits in \texttt{lean}).
Since morphisms are functors, which live in \texttt{Type max (v u)}
this means for any discrete category \texttt{I : Type max (v u)}
(discrete means it has no morphisms between objects),
any diagram of shape \texttt{I} has a limit.
(Informal) Our construction for the limit of this diagram will
likely need to mention the indexing category \texttt{I},
and in doing so will be a type with universe level at least \texttt{max (v u)}.
However, the underlying types of objects in \texttt{Cat.\{v u\}} need to be in \texttt{Type u}.

Instead forcing \texttt{v} and \texttt{u} to be (externally) equal,
then taking the \texttt{max} keeps us in at the same level, and there is no issue.

\subsection{The terminal category}

The terminal category in \texttt{Cat.\{v u\}}
should have an underlying type that looks like a singleton type,
which is called \texttt{punit : Type u} in the library.
Intuitively there should be only one morphism in this category,
namely the identity on the unique object \texttt{punit.star}.

The library contructs such a category more generally,
by taking any type \texttt{X : Type u} and taking the hom
sets between its terms \texttt{x y : X} to be the type \texttt{x = y}.
The issue here is that this hom set is a proposition,
so it must be lifted to the appropriate type by universe lifting.

\[ \texttt{x = y : Prop : Type 0 : Type 1 : ...} \]

The issue here is that it is hard to keep track of the universe we are lifting it to.
The library gets around this by requiring \texttt{ulift (x = y) : Type u},
so that the terminal category is a small category.
However, this is not ideal here, since we want the hom set to be of level \texttt{v}.
Thus I contruct another version of the terminal category.
Since there is exactly one morphism between the obvious point,
I also take the unique hom set to be \texttt{punit : Type v},
but at level \texttt{v} (\texttt{punit} is polymorphic).

\begin{lstlisting}
def terminal : Cat.{v u} :=
{ α := punit,
  str := { hom := λ _ _, punit,
           -- this punit : Type v should to be thought of as `star ⟶ star`
           id := λ _, punit.star, -- there is only one map from `star → star`
           comp := λ _ _ _ _ _, punit.star } }
           -- the composition of this trivial map with itself is itself\end{lstlisting}






\bibliography{refs}{}
\bibliographystyle{abbrv}

\end{document}
