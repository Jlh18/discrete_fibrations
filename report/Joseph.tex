\documentclass{article}
\usepackage[left=1in,right=1in,tmargin = 25mm,bmargin = 25mm]{geometry}
\usepackage[left=1in,right=1in]{geometry}
\usepackage{subfiles}
\usepackage{amsmath, amssymb, stmaryrd, verbatim, bbm, mathabx} % math symbols
\usepackage{amsthm} % thm environment
\usepackage{mdframed} % Customizable Boxes
\usepackage{hyperref,nameref,cleveref,enumitem} % for references, hyperlinks
\usepackage[dvipsnames]{xcolor} % Fancy Colours
\usepackage{mathrsfs} % Fancy font
\usepackage{tikz, tikz-cd, float} % Commutative Diagrams
\usepackage{perpage}
\usepackage{parskip} % So that paragraphs look nice
\usepackage{ifthen,xargs} % For defining better commands
\usepackage{anyfontsize}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage{titlesec}
\usepackage{url}
\usepackage{listings}

% % Misc
\newcommand{\brkt}[1]{\left(#1\right)}
\newcommand{\sqbrkt}[1]{\left[#1\right]}
\newcommand{\dash}{\text{-}}
\newcommand{\tdt}{\times \dots \times}

% % Logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\limplies}{\Leftarrow}
\newcommand{\NOT}{\neg\,}
\newcommand{\AND}{\land}
\newcommand{\OR}{\lor}
\newenvironment{forward}{($\implies$)}{}
\newenvironment{backward}{($\limplies$)}{}
% General way of making larger symbols with limits above and below
\makeatletter
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{
      \ifx#1\displaystyle.7\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}% symbol size
  }%
}
\makeatother
\newcommand{\bigforall}[2]{\DOTSB\bigop{\forall}_{#1}^{#2}}
\newcommand{\bigexists}[2]{\DOTSB\bigop{\exists}_{#1}^{#2}}
\newcommand{\bigand}[2]{\DOTSB\bigop{\mbox{\Large$\land$}}_{#1}^{#2}}
\newcommand{\bigor}[2]{\DOTSB\bigop{\mbox{\Large$\lor$}}_{#1}^{#2}}

% % Sets
\DeclareMathOperator{\supp}{supp}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\st}{\,|\,}
\newcommand{\minus}{\setminus}
\newcommand{\subs}{\subseteq}
\newcommand{\ssubs}{\subsetneq}
\DeclareMathOperator{\im}{Im}
\newcommand{\nothing}{\varnothing}
\newcommand\res[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace
  % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|}
  % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

% % Greek
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\varepsilon}
\newcommand{\io}{\iota}
\newcommand{\ka}{\kappa}
\newcommand{\la}{\lambda}
\newcommand{\om}{\omega}
\newcommand{\si}{\sigma}

\newcommand{\Ga}{\Gamma}
\newcommand{\De}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\La}{\Lambda}
\newcommand{\Si}{\Sigma}
\newcommand{\Om}{\Omega}

% % Mathbb
\newcommand{\A}{\mathbb{A}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\U}{\mathbb{U}}

% % Mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\II}{\mathcal{I}}
\newcommand{\JJ}{\mathcal{J}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\newcommand{\RR}{\mathcal{R}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YY}{\mathcal{Y}}
\newcommand{\ZZ}{\mathcal{Z}}

% % Mathfrak
\newcommand{\f}[1]{\mathfrak{#1}}

% % Mathrsfs
\newcommand{\s}[1]{\mathscr{#1}}

% % Category Theory
\newcommand{\obj}[1]{\mathrm{Obj}\left(#1\right)}
\newcommand{\Hom}[3]{\mathrm{Hom}_{#3}(#1, #2)\,}
\newcommand{\mor}[3]{\mathrm{Mor}_{#3}(#1, #2)\,}
\newcommand{\End}[2]{\mathrm{End}_{#2}#1\,}
\newcommand{\aut}[2]{\mathrm{Aut}_{#2}#1\,}
\newcommand{\CAT}{\mathbf{Cat}}
\newcommand{\SET}{\mathbf{Set}}
\newcommand{\TOP}{\mathbf{Top}}
%\newcommand{\GRP}{\mathbf{Grp}}
\newcommand{\RING}{\mathbf{Ring}}
\newcommand{\MOD}[1][R]{#1\text{-}\mathbf{Mod}}
\newcommand{\VEC}[1][K]{#1\text{-}\mathbf{Vec}}
\newcommand{\ALG}[1][R]{#1\text{-}\mathbf{Alg}}
\newcommand{\PSH}[1]{\mathbf{PSh}\brkt{#1}}
\newcommand{\map}[2]{ \yrightarrow[#2][2.5pt]{#1}[-1pt] }
\newcommand{\op}{^{op}}
\newcommand{\darrow}{\downarrow}
\newcommand{\LIM}[2]{\varprojlim_{#2}#1}
\newcommand{\COLIM}[2]{\varinjlim_{#2}#1}
\newcommand{\hookr}{\hookrightarrow}

% % Algebra
\newcommand{\iso}{\cong}
\newcommand{\nsub}{\trianglelefteq}
\newcommand{\id}[1]{\mathbbm{1}_{#1}}
\newcommand{\inv}{^{-1}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}
\DeclareMathOperator{\coker}{Coker}
\DeclareMathOperator{\spec}{Spec}

% % Analysis
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\renewcommand{\check}[1]{\widecheck{#1}}

% % Galois
\newcommand{\Gal}[2]{\mathrm{Gal}_{#1}(#2)}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}
\newcommand{\emb}[3]{\mathrm{Emb}_{#1}(#2, #3)}
\newcommand{\Char}[1]{\mathrm{Char}#1}

% % Model Theory
\newcommand{\intp}[2]{
    \star_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\subintp}[3]{
    {#3}_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\modintp}[2]{#2^\text{\scalebox{0.7}{$#1$}}}
\newcommand{\mmintp}[1]{\modintp{\MM}{#1}}
\newcommand{\nnintp}[1]{\modintp{\NN}{#1}}
\DeclareMathOperator{\const}{constants}
\DeclareMathOperator{\func}{functions}
\DeclareMathOperator{\rel}{relations}
% \newcommand{\term}[1]{{#1}_\mathrm{ter}}
% \newcommand{\tv}[1]{\textrm{tv}_{#1}}
% \newcommand{\struc}[1]{\mathbf{Str}(#1)}
% \newcommand{\form}[1]{{#1}_\mathrm{for}}
% \newcommand{\var}[1]{{#1}_\mathrm{var}}
% \newcommand{\theory}[1]{{#1}_\mathrm{the}}
% \newcommand{\carrier}[1]{{#1}_\mathrm{car}}
% \newcommand{\model}[1]{\vDash_{#1}}
% \newcommand{\nodel}[1]{\nvDash_{#1}}
% \newcommand{\modelsi}{\model{\Si}}
% \newcommand{\nodelsi}{\nvDash_{\Si}}
% \newcommand{\eldiag}[2]{\mathrm{ElDiag}(#1,#2)}
% \newcommand{\atdiag}[2]{\mathrm{AtDiag}(#1,#2)}
% \newcommand{\Theory}{\mathrm{Th}}
% \newcommand{\unisen}[1]{{#1}_\mathrm{uni}}
\newcommand{\lift}[2]{\uparrow_{#1}^{#2}}
\newcommand{\fall}[2]{\downarrow_{#1}^{#2}}
\DeclareMathOperator{\GRP}{GRP}
\newcommand{\RNG}{\mathrm{RNG}}
\newcommand{\ER}{\mathrm{ER}}
\DeclareMathOperator{\FLD}{FLD}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\ZFC}{ZFC}
\DeclareMathOperator{\ACF}{ACF}
\newcommand{\BLN}{\mathrm{BLN}}
\newcommand{\PO}{\mathrm{PO}}
\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\qftp}{qftp}
\DeclareMathOperator{\qf}{qf}
\DeclareMathOperator{\eqzero}{eqzero}
\newcommand{\MR}[2]{\mathrm{MR}^{#1}(#2)}
\DeclareMathOperator{\MD}{MD}
\DeclareMathOperator{\acl}{acl}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\mdeg}{m.deg}
\DeclareMathOperator{\kdim}{k.dim}
\newcommand{\Mod}[1]{EDITTHIS {#1}}
% % Set theory
\DeclareMathOperator{\ord}{Ord}

% % Boolean algebra
\newcommand{\NEG}{\smallsetminus}
\newcommand{\upa}[1]{#1^{\uparrow}}

% % Field theory
\DeclareMathOperator{\tdeg}{t.deg}
\newcommand{\zmo}[2][p]{\Z/#1^{#2}\Z}

%% code from mathabx.sty and mathabx.dcl to get some symbols from mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}

% Arrows with text above and below with adjustable displacement
% (Stolen from Stackexchange)
\newcommandx{\yaHelper}[2][1=\empty]{
\ifthenelse{\equal{#1}{\empty}}
  % no offset
  { \ensuremath{ \scriptstyle{ #2 } } }
  % with offset
  { \raisebox{ #1 }[0pt][0pt]{ \ensuremath{ \scriptstyle{ #2 } } } }
}

\newcommandx{\yrightarrow}[4][1=\empty, 2=\empty, 4=\empty, usedefault=@]{
  \ifthenelse{\equal{#2}{\empty}}
  % there's no text below
  { \xrightarrow{ \protect{ \yaHelper[ #4 ]{ #3 } } } }
  % there's text below
  {
    \xrightarrow[ \protect{ \yaHelper[ #2 ]{ #1 } } ]
    { \protect{ \yaHelper[ #4 ]{ #3 } } }
  }
}

% xcolor
\definecolor{darkgrey}{gray}{0.10}
\definecolor{lightgrey}{gray}{0.30}
\definecolor{slightgrey}{gray}{0.80}
\definecolor{softblue}{RGB}{30,100,200}

% hyperref
\hypersetup{
      colorlinks = true,
      linkcolor = {softblue},
      citecolor = {blue}
}

\newcommand{\link}[1]{\hypertarget{#1}{}}
\newcommand{\linkto}[2]{\hyperlink{#1}{#2}}

% Theorems

% % custom theoremstyles
\newtheoremstyle{definitionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % custom theoremstyles
\newtheoremstyle{propositionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

\newtheoremstyle{exercisestyle}%
{0pt}% above thm
{0pt}% below thm
{\it}% body font
{}% space to indent
{\scshape}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{ (#3)}}

\newtheoremstyle{remarkstyle}%
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\it}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % Theorem environments

\theoremstyle{definitionstyle}
\newmdtheoremenv[
    %skipabove = \baselineskip
    linewidth = 2pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{dfn}{Definition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{prop}{Proposition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{cor}{Corollary}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{lem}{Lemma}


\theoremstyle{exercisestyle}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{ex}{Exercise}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{eg}{Example}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{nttn}{Notation}

\theoremstyle{remarkstyle}
\newtheorem{rmk}{Remark}

% % footnotes
\renewcommand{\thempfootnote}{$\dagger$}
\MakePerPage{footnote}

% % tikzcd diagram
\newenvironment{cd}{
    \begin{figure}[H]
    \centering
    \begin{tikzcd}
}{
    \end{tikzcd}
    \end{figure}
}

% tikzcd
% % Substituting symbols for arrows in tikz comm-diagrams.
\tikzset{
  symbol/.style={
    draw=none,
    every to/.append style={
      edge node={node [sloped, allow upside down, auto=false]{$#1$}}}
  }
}


\titlespacing*{\section}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}

% Syntax highlighting for lean

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.6, 0.3, 0.6}   % light purple
\definecolor{tacticcolor}{rgb}{0.2, 0.2, 0.6}    % dark purple
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.7, 0.2, 0.2}    % blue
\definecolor{sortcolor}{rgb}{0.2, 0.7, 0.7}      % cyan
\definecolor{attributecolor}{RGB}{120,0,0}       % maroon
\definecolor{draculaGrey}{RGB}{25, 27, 15}       % grey

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\begin{document}
\title{Limits in the category of categories}
\author{Joseph Hua}
\maketitle


\section{Introduction}

In this project, I show that \texttt{Cat.\{u u\}}, the category of small categories
is complete, where ``small'' in \texttt{lean} is taken to mean
the universe levels (sizes) for objects and morphisms is the same.
I also show that \texttt{Cat.\{v u\}}, the category of all categories
(up to appropriate universe levels) has all finite limits.
Since the category of categories is a bicategory,
and it is quite rare in practice to work with strict equality of functors,
the ``morally correct'' limits to consider should really be 2-limits,
where the functors are considered up to natural isomorphism.
However, these are not considered here, since existence of 1-limits holds anyway.
This should deduce the 2-limit case, as equal funtors are trivially naturally isomorphic.

An obvious next step is to show results for colimits, which I have not yet done.

\section{Relevant definitions and results in mathlib}

The category theory library in \texttt{mathlib} already contains definitions for
limits, using cones over diagrams.

\begin{dfn}[Diagrams, cones and limits]
  A diagram in a category $\CC$ is simply a functor from some category
  $F : \II \to \CC$, and $\II$ is called the shape.
  Diagrams are not explicitely defined in \texttt{lean},
  as this would lead to extra unnecessary definitional equalities.

  % https://q.uiver.app/?q=WzAsNixbNiwwLCJcXG1hdGhjYWx7Rn0gaiJdLFs0LDAsIlxcbWF0aGNhbHtGfSBpIl0sWzAsMCwiaSJdLFsxLDAsImoiXSxbMiwwXSxbMywwXSxbMSwwLCJcXG1hdGhjYWx7Rn0gXFxwaGkiLDIseyJjdXJ2ZSI6M31dLFsxLDAsIlxcbWF0aGNhbHtGfSBcXHBzaSIsMCx7ImN1cnZlIjotM31dLFsyLDMsIlxccGhpIiwyLHsiY3VydmUiOjJ9XSxbMiwzLCJcXHBzaSIsMCx7ImN1cnZlIjotMn1dLFs0LDUsIiIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRvdHRlZCJ9fX1dXQ==
  \[\begin{tikzcd}
  	i & j & {} & {} & {\mathcal{F} i} && {\mathcal{F} j}
  	\arrow["{\mathcal{F} \phi}"', bend right={30}, from=1-5, to=1-7]
  	\arrow["{\mathcal{F} \psi}", bend right={-30}, from=1-5, to=1-7]
  	\arrow["\phi"', bend right={30}, from=1-1, to=1-2]
  	\arrow["\psi", bend right={-30}, from=1-1, to=1-2]
  	\arrow["{\mathcal{F}}", dotted, from=1-3, to=1-4]
  \end{tikzcd}\]
  \[ \text{\small A diagram for equalizers}\]

  A cone over a diagram $F : \JJ \to \CC$ consists of an apex $X$ an object in $\CC$
  and a natural transformation from (the constant functor at) $X$ to $F$.
  This natural transformation captures the data of legs from $X$ into the diagram
  that commute with the maps in the diagram.

  \begin{lstlisting}
    structure cone (F : J ⥤ C) :=
    (X : C) (π : (const J).obj X ⟶ F) \end{lstlisting}

  Here \texttt{lean} recognizes that \texttt{F} is a functor,
  so it infers that the categorical map into \texttt{F} should be
  in the functor fategory, i.e. a natural transformation.

    \[\begin{tikzcd}
  	& X \\
  	\\
  	{\mathcal{F} i} && {\mathcal{F} j}
  	\arrow["{\mathcal{F} \phi}"', bend right={30}, from=3-1, to=3-3]
  	\arrow["{\mathcal{F} \psi}", bend right={-30}, from=3-1, to=3-3]
  	\arrow["{\pi \, i}"', from=1-2, to=3-1]
  	\arrow["{\pi \, j}", from=1-2, to=3-3]
  \end{tikzcd}\]
  \[ \text{\small A cone over the equalizer diagram, or a ``fork''}\]

  Finally, the data of a cone $l$ being the limit of a diagram consists of
  \begin{itemize}
    \item (\texttt{lift}) For any cone $c$, a map $\texttt{lift} : c \to l$ in the category $\CC$.
    \item (\texttt{fac}) A proof that \texttt{lift} commutes with everything else in the diagram.
    \item (\texttt{uniq}) Any other map $c \to l$ commuting with everything is equal to \texttt{lift}.
  \end{itemize}

  Put another way, a limit of a diagram is the terminal object when considering
  the cones as a category.

  \begin{lstlisting}
    structure is_limit (t : cone F) :=
    (lift  : Π (s : cone F), s.X ⟶ t.X)
    (fac'  : ∀ (s : cone F) (j : J), lift s ≫ t.π.app j = s.π.app j . obviously)
    (uniq' : ∀ (s : cone F) (m : s.X ⟶ t.X) (w : ∀ j : J, m ≫ t.π.app j = s.π.app j),
    m = lift s . obviously)
  \end{lstlisting}

  Note that \texttt{lift} is data, whereas the others are propositional.
  Also note that \texttt{fac'} and \texttt{uniq'}
  are appended with \texttt{obviously}.
  This means that when we construct a limit, we could only
  supply the \texttt{lift}, and let \texttt{lean} figure the rest out.
  Many of the structures in the category theory library use this
  so that making instances of categories, functors, natural transformations,
  and limits less work.

  \[\begin{tikzcd}
    & c \\
  	& l \\
  	\\
  	{\mathcal{F} i} && {\mathcal{F} j}
  	\arrow["{\mathcal{F} \phi}"', bend right={30}, from=4-1, to=4-3]
  	\arrow["{\mathcal{F} \psi}", bend right={-30}, from=4-1, to=4-3]
  	\arrow[from=1-2, to=4-1]
  	\arrow[from=1-2, to=4-3]
  	\arrow[from=2-2, to=4-1]
  	\arrow[from=2-2, to=4-3]
    \arrow[dashed, from=1-2, to=2-2]
  \end{tikzcd}\]
  \[ \text{\small $l$ is the equalizer of $\FF \phi$ and $\FF \psi$}\]
\end{dfn}

All of the following are results from \texttt{mathlib} that I will be using in my work.
\begin{itemize}
  \item (Categorical) definitions of binary and arbitrary products,
        equalizers, and pullback.
        Browsable \href{https://leanprover-community.github.io/mathlib_docs/category_theory/limits/shapes/products.html}{here}.
  \item A proof that categories with products and equalizers has all small limits.
        A proof that categories with finite products and equalizers is complete.
        A proof that categories with binary products and terminal objects has finite products.
        Browsable \href{https://leanprover-community.github.io/mathlib_docs/category_theory/limits/constructions/limits_of_products_and_equalizers.html}{here}.
  \item The product of categories (as a category, \textit{not} as an object in \texttt{Cat.\{v u\}}).
        Browsable \href{https://leanprover-community.github.io/mathlib_docs/category_theory/pi/basic.html}{here}.
  \item The binary product of categories (as a category. \textit{not} as an object in \texttt{Cat.\{v u\}}).
        Browsable \href{https://leanprover-community.github.io/mathlib_docs/category_theory/products/basic.html}{here}.
\end{itemize}

\section{The process of giving a limit}

In this section I walk through the general process of giving a limit,
by following my work on binary products.
This was the first example I worked on, and I think it
demonstrates the process well, having the fewest technicalities.

We begin by giving the object in the category of categories
that we are interested in constructing.
The definition of the category of categories essentially consists
of two pieces of data, $\al$ the underlying type,
and \texttt{str} an \texttt{instance} of $\al$ as a category.
The second piece of data is given the parameter \texttt{obviously},
so we need not specify it in our construction:

\begin{lstlisting}
def prod (C D : Cat.{v u}) : Cat.{v u} := { α := (C.α × D.α) } \end{lstlisting}

The underlying type of the product is simply of product
of the underlying types of \texttt{C} and \texttt{D}.
The library already has \href{https://leanprover-community.github.io/mathlib_docs/category_theory/products/basic.html}{an \texttt{instance}}
of this type as a category, so the type is all we need.

We promote this to a cone, by defining the natural transformation from
the constant functor at \texttt{prod} to the diagram.
The diagram in question is called \texttt{pair} and its shape
(a category with just two objects with no morphisms) is (a type that looks exactly like) \texttt{Bool}.
A \texttt{mathlib} lemma \texttt{map\_pair} (specialized to our use case) that says to make a
natural transformation into a \texttt{Bool} shaped diagram,
it suffices to just give a map into each of the two objects in the diagram.
Hence we have a slick definition

\begin{lstlisting}
def cone (C D : Cat.{v u}) : cone (pair C D) :=
{ X := prod C D,
  π := map_pair (fst _ _) (snd _ _) } \end{lstlisting}

We intend for this cone to be the limit.
Which consists of a \texttt{lift}, \texttt{fac}torizations through the \texttt{lift},
and \texttt{uniq}ness of the lift.

Constructing the lift generally amounts to constructing maps for objects and morphisms
by destructing the definition of the limit cone.
In this particular case, since the limit cone is a product of categories,
to make objects and morphisms in it we need to give pairs of objects
and morphisms from each category.
Since cones over this diagram only really consist of functors from the apex
into \texttt{C} and \texttt{D}, giving the \texttt{lift} is a corollary of this definition:

\begin{lstlisting}
def lift (f : E ⟶ C) (g : E ⟶ D) : (E ⟶ prod C D) :=
{ obj := λ z, ⟨ f.obj z , g.obj z ⟩,
  map := λ _ _ h, ⟨ f.map h , g.map h ⟩ }\end{lstlisting}

The remaining two parts of this construction involve proving an equality bewteen two functors,
which deserves some interesting design decisions.
We leave this discussion to the next section.

\section{Equality between functors}

In the introduction it was mentioned that strict equality between
functors was not ``morally correct''.
This is exemplified when we try to prove such an equality.
Naively, extensionality for functors should say two functors $F G : \CC \to \DD$
should be equal if and only if they are equal on objects and on morphisms.
However, type theory complicates this issue for morphisms.
If $x$ and $y$ are objects in $\CC$ and we have proofs that $F x = G x$ and $F y = G y$,
it doesn't make sense to ask for a morphism $f : x \to y$ whether $F f = G f$,
because these are terms of types that are not definitionally equal.
Namely $F f : F x \to F y$ and $G f : G x \to G y$.

The obvious workaround to this issue is to instead ask for a commutative square
where the sides are given by the equalities we have (equal objects are certainly isomorphic).
\[\begin{tikzcd}
	{F x} & {F y} \\
	Gx & Gy
	\arrow["{F f}", from=1-1, to=1-2]
	\arrow["{\texttt{eq\_to\_hom}}"', from=1-1, to=2-1]
	\arrow["Gf"', from=2-1, to=2-2]
	\arrow["{\texttt{eq\_to\_hom}}"', from=2-2, to=1-2]
\end{tikzcd}\]
Whilst this method works - I used it in my first round of proofs,
it can be improved with a clever trick.

Instead of considering strict equality ($=$) on morphisms,
Xu Junyan on Zulip suggested using \texttt{heq}uality ($==$) instead.
This different version of equality is also a proposition whose only
proof is \texttt{refl} (that the two terms are the same),
but this question to be asked even when their ambient types are different.
Hence in the above example I could simply write $F f == G f$,
though I would not be able to prove it until I make the two sides
definitionally equal.
The benefit of this definition is that one doesn't need to deal with the
extra compositions the original workaround introduces.
In the end whatever types we are working with should be equal
anyway, so it is more straight forward to first imagine that they are and realise that
this is the case later.

A useful result from the library is \texttt{functor.hext},
which says that two functors are equal if they are equal on objects and
\texttt{heq}ual on morphisms.

% Things I want to talk about
% \item equality of functors -> definition of heq and comparison with eq
% \item definition of equalizer wrt eq / heq
% \item refactoring through lifts
% \item universe levels for terminal object
% \item why arbitrary products must be small






\bibliography{refs}{}
\bibliographystyle{abbrv}

\end{document}
