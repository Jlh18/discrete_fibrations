\documentclass{article}
\usepackage[left=1in,right=1in,tmargin = 25mm,bmargin = 25mm]{geometry}
\usepackage[left=1in,right=1in]{geometry}
\usepackage{subfiles}
\usepackage{amsmath, amssymb, stmaryrd, verbatim, bbm, mathabx} % math symbols
\usepackage{amsthm} % thm environment
\usepackage{mdframed} % Customizable Boxes
\usepackage{hyperref,nameref,cleveref,enumitem} % for references, hyperlinks
\usepackage[dvipsnames]{xcolor} % Fancy Colours
\usepackage{mathrsfs} % Fancy font
\usepackage{tikz, tikz-cd, float} % Commutative Diagrams
\usepackage{perpage}
\usepackage{parskip} % So that paragraphs look nice
\usepackage{ifthen,xargs} % For defining better commands
\usepackage{anyfontsize}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage{titlesec}
\usepackage{url}
\usepackage{listings}

% local

\DeclareMathOperator{\PSh}{Psh}
\newcommand{\functor}{\rightrightharpoons}

% % Misc
\newcommand{\brkt}[1]{\left(#1\right)}
\newcommand{\sqbrkt}[1]{\left[#1\right]}
\newcommand{\dash}{\text{-}}
\newcommand{\tdt}{\times \dots \times}

% % Logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\limplies}{\Leftarrow}
\newcommand{\NOT}{\neg\,}
\newcommand{\AND}{\land}
\newcommand{\OR}{\lor}
\newenvironment{forward}{($\implies$)}{}
\newenvironment{backward}{($\limplies$)}{}
% General way of making larger symbols with limits above and below
\makeatletter
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{
      \ifx#1\displaystyle.7\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}% symbol size
  }%
}
\makeatother
\newcommand{\bigforall}[2]{\DOTSB\bigop{\forall}_{#1}^{#2}}
\newcommand{\bigexists}[2]{\DOTSB\bigop{\exists}_{#1}^{#2}}
\newcommand{\bigand}[2]{\DOTSB\bigop{\mbox{\Large$\land$}}_{#1}^{#2}}
\newcommand{\bigor}[2]{\DOTSB\bigop{\mbox{\Large$\lor$}}_{#1}^{#2}}

% % Sets
\DeclareMathOperator{\supp}{supp}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\st}{\,|\,}
\newcommand{\minus}{\setminus}
\newcommand{\subs}{\subseteq}
\newcommand{\ssubs}{\subsetneq}
\DeclareMathOperator{\im}{Im}
\newcommand{\nothing}{\varnothing}
\newcommand\res[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace
  % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|}
  % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

% % Greek
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\varepsilon}
\newcommand{\io}{\iota}
\newcommand{\ka}{\kappa}
\newcommand{\la}{\lambda}
\newcommand{\om}{\omega}
\newcommand{\si}{\sigma}

\newcommand{\Ga}{\Gamma}
\newcommand{\De}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\La}{\Lambda}
\newcommand{\Si}{\Sigma}
\newcommand{\Om}{\Omega}

% % Mathbb
\newcommand{\A}{\mathbb{A}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\U}{\mathbb{U}}

% % Mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\II}{\mathcal{I}}
\newcommand{\JJ}{\mathcal{J}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\newcommand{\RR}{\mathcal{R}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YY}{\mathcal{Y}}
\newcommand{\ZZ}{\mathcal{Z}}

% % Mathfrak
\newcommand{\f}[1]{\mathfrak{#1}}

% % Mathrsfs
\newcommand{\s}[1]{\mathscr{#1}}

% % Category Theory
\newcommand{\obj}[1]{\mathrm{Obj}\left(#1\right)}
\newcommand{\Hom}[3]{\mathrm{Hom}_{#3}(#1, #2)\,}
\newcommand{\mor}[3]{\mathrm{Mor}_{#3}(#1, #2)\,}
\newcommand{\End}[2]{\mathrm{End}_{#2}#1\,}
\newcommand{\aut}[2]{\mathrm{Aut}_{#2}#1\,}
\newcommand{\CAT}{\mathbf{Cat}}
\newcommand{\SET}{\mathbf{Set}}
\newcommand{\TOP}{\mathbf{Top}}
%\newcommand{\GRP}{\mathbf{Grp}}
\newcommand{\RING}{\mathbf{Ring}}
\newcommand{\MOD}[1][R]{#1\text{-}\mathbf{Mod}}
\newcommand{\VEC}[1][K]{#1\text{-}\mathbf{Vec}}
\newcommand{\ALG}[1][R]{#1\text{-}\mathbf{Alg}}
\newcommand{\PSH}[1]{\mathbf{PSh}\brkt{#1}}
\newcommand{\map}[2]{ \yrightarrow[#2][2.5pt]{#1}[-1pt] }
\newcommand{\op}{^{op}}
\newcommand{\darrow}{\downarrow}
\newcommand{\LIM}[2]{\varprojlim_{#2}#1}
\newcommand{\COLIM}[2]{\varinjlim_{#2}#1}
\newcommand{\hookr}{\hookrightarrow}

% % Algebra
\newcommand{\iso}{\cong}
\newcommand{\nsub}{\trianglelefteq}
\newcommand{\id}[1]{\mathbbm{1}_{#1}}
\newcommand{\inv}{^{-1}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}
\DeclareMathOperator{\coker}{Coker}
\DeclareMathOperator{\spec}{Spec}

% % Analysis
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\renewcommand{\check}[1]{\widecheck{#1}}

% % Galois
\newcommand{\Gal}[2]{\mathrm{Gal}_{#1}(#2)}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}
\newcommand{\emb}[3]{\mathrm{Emb}_{#1}(#2, #3)}
\newcommand{\Char}[1]{\mathrm{Char}#1}

% % Model Theory
\newcommand{\intp}[2]{
    \star_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\subintp}[3]{
    {#3}_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\modintp}[2]{#2^\text{\scalebox{0.7}{$#1$}}}
\newcommand{\mmintp}[1]{\modintp{\MM}{#1}}
\newcommand{\nnintp}[1]{\modintp{\NN}{#1}}
\DeclareMathOperator{\const}{constants}
\DeclareMathOperator{\func}{functions}
\DeclareMathOperator{\rel}{relations}
% \newcommand{\term}[1]{{#1}_\mathrm{ter}}
% \newcommand{\tv}[1]{\textrm{tv}_{#1}}
% \newcommand{\struc}[1]{\mathbf{Str}(#1)}
% \newcommand{\form}[1]{{#1}_\mathrm{for}}
% \newcommand{\var}[1]{{#1}_\mathrm{var}}
% \newcommand{\theory}[1]{{#1}_\mathrm{the}}
% \newcommand{\carrier}[1]{{#1}_\mathrm{car}}
% \newcommand{\model}[1]{\vDash_{#1}}
% \newcommand{\nodel}[1]{\nvDash_{#1}}
% \newcommand{\modelsi}{\model{\Si}}
% \newcommand{\nodelsi}{\nvDash_{\Si}}
% \newcommand{\eldiag}[2]{\mathrm{ElDiag}(#1,#2)}
% \newcommand{\atdiag}[2]{\mathrm{AtDiag}(#1,#2)}
% \newcommand{\Theory}{\mathrm{Th}}
% \newcommand{\unisen}[1]{{#1}_\mathrm{uni}}
\newcommand{\lift}[2]{\uparrow_{#1}^{#2}}
\newcommand{\fall}[2]{\downarrow_{#1}^{#2}}
\DeclareMathOperator{\GRP}{GRP}
\newcommand{\RNG}{\mathrm{RNG}}
\newcommand{\ER}{\mathrm{ER}}
\DeclareMathOperator{\FLD}{FLD}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\ZFC}{ZFC}
\DeclareMathOperator{\ACF}{ACF}
\newcommand{\BLN}{\mathrm{BLN}}
\newcommand{\PO}{\mathrm{PO}}
\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\qftp}{qftp}
\DeclareMathOperator{\qf}{qf}
\DeclareMathOperator{\eqzero}{eqzero}
\newcommand{\MR}[2]{\mathrm{MR}^{#1}(#2)}
\DeclareMathOperator{\MD}{MD}
\DeclareMathOperator{\acl}{acl}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\mdeg}{m.deg}
\DeclareMathOperator{\kdim}{k.dim}
\newcommand{\Mod}[1]{EDITTHIS {#1}}
% % Set theory
\DeclareMathOperator{\ord}{Ord}

% % Boolean algebra
\newcommand{\NEG}{\smallsetminus}
\newcommand{\upa}[1]{#1^{\uparrow}}

% % Field theory
\DeclareMathOperator{\tdeg}{t.deg}
\newcommand{\zmo}[2][p]{\Z/#1^{#2}\Z}

%% code from mathabx.sty and mathabx.dcl to get some symbols from mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}

% Arrows with text above and below with adjustable displacement
% (Stolen from Stackexchange)
\newcommandx{\yaHelper}[2][1=\empty]{
\ifthenelse{\equal{#1}{\empty}}
  % no offset
  { \ensuremath{ \scriptstyle{ #2 } } }
  % with offset
  { \raisebox{ #1 }[0pt][0pt]{ \ensuremath{ \scriptstyle{ #2 } } } }
}

\newcommandx{\yrightarrow}[4][1=\empty, 2=\empty, 4=\empty, usedefault=@]{
  \ifthenelse{\equal{#2}{\empty}}
  % there's no text below
  { \xrightarrow{ \protect{ \yaHelper[ #4 ]{ #3 } } } }
  % there's text below
  {
    \xrightarrow[ \protect{ \yaHelper[ #2 ]{ #1 } } ]
    { \protect{ \yaHelper[ #4 ]{ #3 } } }
  }
}

% xcolor
\definecolor{darkgrey}{gray}{0.10}
\definecolor{lightgrey}{gray}{0.30}
\definecolor{slightgrey}{gray}{0.80}
\definecolor{softblue}{RGB}{30,100,200}

% hyperref
\hypersetup{
      colorlinks = true,
      linkcolor = {softblue},
      citecolor = {blue}
}

\newcommand{\link}[1]{\hypertarget{#1}{}}
\newcommand{\linkto}[2]{\hyperlink{#1}{#2}}

% Theorems

% % custom theoremstyles
\newtheoremstyle{definitionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % custom theoremstyles
\newtheoremstyle{propositionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

\newtheoremstyle{exercisestyle}%
{0pt}% above thm
{0pt}% below thm
{\it}% body font
{}% space to indent
{\scshape}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{ (#3)}}

\newtheoremstyle{remarkstyle}%
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\it}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % Theorem environments

\theoremstyle{definitionstyle}
\newmdtheoremenv[
    %skipabove = \baselineskip
    linewidth = 2pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{dfn}{Definition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{prop}{Proposition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{cor}{Corollary}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{lem}{Lemma}


\theoremstyle{exercisestyle}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{ex}{Exercise}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{eg}{Example}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{nttn}{Notation}

\theoremstyle{remarkstyle}
\newtheorem{rmk}{Remark}

% % footnotes
\renewcommand{\thempfootnote}{$\dagger$}
\MakePerPage{footnote}

% % tikzcd diagram
\newenvironment{cd}{
    \begin{figure}[H]
    \centering
    \begin{tikzcd}
}{
    \end{tikzcd}
    \end{figure}
}

% tikzcd
% % Substituting symbols for arrows in tikz comm-diagrams.
\tikzset{
  symbol/.style={
    draw=none,
    every to/.append style={
      edge node={node [sloped, allow upside down, auto=false]{$#1$}}}
  }
}


\titlespacing*{\section}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}

% Syntax highlighting for lean

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.6, 0.3, 0.6}   % light purple
\definecolor{tacticcolor}{rgb}{0.2, 0.2, 0.6}    % dark purple
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.7, 0.2, 0.2}    % blue
\definecolor{sortcolor}{rgb}{0.2, 0.7, 0.7}      % cyan
\definecolor{attributecolor}{RGB}{120,0,0}       % maroon
\definecolor{draculaGrey}{RGB}{25, 27, 15}       % grey

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\begin{document}
\title{Presheaves over the category of elements of a presheaf}
\author{Joseph Hua}
\maketitle

\section{Conventions}

We call functors $P : \CC \functor \UU$ for some universe $\UU$
a presheaf, although the convention is usually dual, with $\CC^{\op}$ instead.
Since the proofs work exactly the same for the dual case, this is justified.

\section{The goal}

In the file \texttt{over\_presheaf.lean} we prove a category-theoretic lemma
that says if $P : \CC \functor \UU$ is a presheaf on category $\CC$ then
the category of presheaves over the category of elements of $P$ is equivalent
to the over category of $P$.
\[ \PSh(\Sigma P) \iso \PSh(C) / P \]
In lean this is stated as

\begin{lstlisting}
  def equivalence : (P.elements ⥤ Type u₀) ≅ over P :=
  { functor := _,
    inverse := _,
    iso := _,
    counit_iso := _ } \end{lstlisting}

Since presheaves on a category $\CC$ is defined as the functors
from $\CC$ into the universe, which in type theory is taken to be
\texttt{Type u}$_{0}$ for some universe level $u_{0}$.
There are four\footnote{There is an extra one, the ``triangle law'',
  but it is automatically generated by \texttt{obviously} in this case.}
fields required to define an equivalence of
categories: the functors forwards and back, and proof that they are left and
right inverses.

The idea is that a presheaf on $\CC$ takes any object $X : \CC$ to
the set of generalized elements of $X$, which are points
$p : \star \to P X$ ($\star : \UU$ is the terminal object in the universe).
Then a presheaf $F$ on $\Sigma P$ takes any object
$\< X : \CC , p : P X \>$ in the category of elements of $P$ to a
generalized elements of $X$ that commute with $p$,
forming points $f : \star \to F\< X , p \>$.
\[\begin{tikzcd}
	\star & F\<X,p\> \\
        & P X
	\arrow["f", from=1-1, to=1-2]
	\arrow["p"', from=1-1, to=2-2]
	\arrow[from=1-2, to=2-2]
\end{tikzcd}\]
If we collect these generalized elements under $F$
across all $p : \star \to X$ then we can get a map
$\Sigma_{p : \star \to X} F\< X , p \> \to P X$
with each $F\< X , p \>$ the fiber of a point $p$.

\[\begin{tikzcd}
	\star & \Sigma_{p} F\<X,p\> \\
        & P X
	\arrow["\<p . f\>", from=1-1, to=1-2]
	\arrow["p"', from=1-1, to=2-2]
	\arrow[two heads, from=1-2, to=2-2]
\end{tikzcd}\]

Thus to make a functor forward, we take a functor $F : \PSh(\Sigma P) \to \UU$
and make a presheaf by
\[ (X : \CC) \mapsto \Sigma_{p : \star \to X} F \< X , p \> : \UU \]
It is in the over category of $P$ since we have a map down to each generalized set $P X$
with fibers $F \< X , p \>$.

To make an inverse, we take a presheaf $Q : \CC \functor \UU$ over $P$,
meaning we have a natural transformation $\al : Q \implies P$,
and produce a presheaf on $\Sigma P$ by taking an object $\< X,p \> : \Sigma P$
and picking out the generalized elements of $X$ under $Q$
that commute with $p$.
This is the pullback
\[\begin{tikzcd}
	{\alpha_X^{-1}p} & \star \\
	{Q X} & {P X}
	\arrow["p", from=1-2, to=2-2]
	\arrow[from=2-1, to=2-2]
	\arrow[from=1-1, to=1-2]
	\arrow[dashed, hook, from=1-1, to=2-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
\end{tikzcd}\]

\section{Forwards}

To construct the functor forwards, we must functorially construct for each
functor \texttt{F : P.elements $\functor$ Type u}$_{0}$ an object of the
over category \texttt{over P}.
An object of the over category \texttt{over P} consists of a presheaf
\texttt{to\_presheaf\_obj F : C $\functor$ Type u}$_{0}$
and a natural transformation down to \texttt{P}.
As described above, we define the presheaf part by taking the sum
of generalized elements from $F$

\begin{lstlisting}
def to_presheaf_obj : C ⥤ Type u₀ :=
{ obj := λ X, Σ p : P.obj X, F.obj ⟨ X , p ⟩,
  map := λ X Y h, λ ⟨ p , f ⟩, ⟨ P.map h p , F.map (hom_mk h rfl) f ⟩,
  map_id' := _,
  map_comp' := _ } \end{lstlisting}

For mapping morphisms, the obvious thing to do is to send the point $p$
along by the image under $P$ of the morphism $h$,
and send $f$ along the image under $F$ of the morphism
in the category of elements induced by $h$.

\subsection{\texttt{obj\_mk} and \texttt{hom\_mk}}
To expain \texttt{hom\_mk}:
For design purposes, it is convenient to make functions \texttt{obj\_mk}
and \texttt{hom\_mk} that produce objects and morphisms in the category
of elements of $P$\footnote{We could use brackets $\<\_,\_\>$
  and provide the type each time, but this is harder on the eyes. };
objects are given by objects $X : \CC$ and generalized elements $p : P X$
and morphisms are given by morphisms $h : X \to Y$ and proofs that
$h$ respects the points in $X$ and $Y$.

\begin{lstlisting}
/-- Explicit, typed construction of an object in category of elements -/
def obj_mk (X : C) (p : P.obj X) : P.elements := ⟨ X , p ⟩

/-- Explicit, typed construction of a hom in category of elements -/
def hom_mk {X Y : C} {pX : P.obj X} {pY : P.obj Y} (h : X ⟶ Y) (hcomm : P.map h pX = pY) :
  obj_mk X pX ⟶ obj_mk Y pY := ⟨ h , hcomm ⟩\end{lstlisting}

\subsection{\texttt{heq} issues}
Above we gave the data of what the presheaf on $\CC$ does,
but \texttt{obviously} is not able to show that this respects the identity
and composition, because there are definitional equality issues.
For the identity we let $X : \CC$ be an object and consider whether
we are sending the identity on $X$ to the identity on the sigma type.
The problem is, the image of the identity is the function
\begin{lstlisting}
  λ ⟨ p , f ⟩, ⟨ P.map (𝟙 X) p , F.map (hom_mk (𝟙 X) rfl) f ⟩ \end{lstlisting}
where the second component has type
\begin{lstlisting}
  F.obj ⟨ X , P.map (𝟙 X) p ⟩ \end{lstlisting}
whereas the identity on the image will have second component
\begin{lstlisting}
  f : F.obj ⟨ X , p ⟩ \end{lstlisting}
It makes sense to ask if the functions are equal,
but to prove this we must use functional extensionality,
introducing such a pair $\< p , f \>$.
It makes sense to ask if their images are equal as terms in the sigma type,
\begin{lstlisting}
  Σ p : P.obj X, F.obj ⟨ X , p ⟩ \end{lstlisting}
but to prove this we must use extensionality on the sigma type,
which introduces \texttt{heq}, since the types on the second part are not
definitionally equal.
Hence the proof goes
\begin{lstlisting}
def to_presheaf_obj : C ⥤ Type u₀ :=
{ obj := ...,
  map := ...,
  map_id' := λ X, funext (λ ⟨ p , f ⟩,
    by { ext, { simp [to_presheaf_obj._match_1] }, ??? }),
    map_comp' := ...} \end{lstlisting}
The first goal is a true equality and can be closed by simplifying
until both sides are just $p$.
The second goal (currently \texttt{???}) is the
\texttt{heq}uality and needs care.
The goal reduces to asking for a proof that
\begin{lstlisting}
  F.map (hom_mk (𝟙 X) rfl) f == f \end{lstlisting}
We hope that we can use transitivity of \texttt{heq} to break this up into
\begin{lstlisting}
  F.map (hom_mk (𝟙 X) rfl) f == F.map (𝟙 ⟨X, p⟩) f == f \end{lstlisting}
Where the last \texttt{heq}uality is a definitional equality,
and is true since functor $F$ preserves the identity.
The first equality naively looks like two applications of \texttt{congr},
but for \texttt{heq}.
Indeed we make such a lemma

\begin{lstlisting}
  lemma hcongr_fun {f₀ : α → β₀} {f₁ : α → β₁} (hβ : β₀ = β₁) (hf : f₀ == f₁) (a : α) :
    f₀ a == f₁ a := by { subst hβ, subst hf } \end{lstlisting}

Applying the above removes $f$, reducing the goal to
\begin{lstlisting}
  F.map (hom_mk (𝟙 X) rfl) == F.map (𝟙 ⟨X, p⟩) \end{lstlisting}
This is surprisingly straight forward
\begin{lstlisting}
  lemma map_hom_mk_id_heq_map_id {X : C} {p : P.obj X} {F : P.elements ⥤ Type u₀} :
    F.map (hom_mk (𝟙 X) rfl) == F.map (𝟙 ⟨ X , p ⟩) :=
  by { congr', {simp}, {simp} } \end{lstlisting}

\subsection{The rest of the functor}

The story for \texttt{map\_comp'} is similar, and not worth examining in detail.
To summarize,
the above gave us a presheaf on $\CC$ for each presheaf on $\Sigma P$.
We want to make this construction a functor, rather than just a function.
So we also define a function on maps (natural transformations in our case
since the objects are functors)

\begin{lstlisting}
  def to_presheaf_map (α : F ⟶ G) : to_presheaf_obj F ⟶ to_presheaf_obj G :=
  { app := λ X ⟨ p , f ⟩, ⟨ p , α.app _ f ⟩,
    naturality' := λ X Y h, funext (λ ⟨ p , f ⟩, by { ext,
      { simp [to_presheaf_map._match_1, to_presheaf_obj] },
      { apply heq_of_eq, exact congr_fun
        (@nat_trans.naturality _ _ _ _ _ _ α ⟨ X , p ⟩ ⟨ Y , P.map h p ⟩ ⟨ h , rfl ⟩) f }})} \end{lstlisting}

The natural transformation at each object $X : \CC$ is
given extensionally as a map between sigma types such that for each
generalized element $p$ of $X$ under $P$, the diagram commutes
\[\begin{tikzcd}
	{F \< X , p \>} & {G\<X,p\>} \\
	\star & PX
	\arrow["{\alpha _X}", from=1-1, to=1-2]
	\arrow["f", from=2-1, to=1-1]
	\arrow["p"', from=2-1, to=2-2]
	\arrow[from=1-2, to=2-2]
	\arrow[from=1-1, to=2-2]
	\arrow[dashed, from=2-1, to=1-2]
\end{tikzcd}\]
Since this map is defined component-wise,
we use extensionality on the sigma type to check naturality,
and it follows from naturality of $\al$,
i.e. the outer square commutes because each inner square commutes,
where going to the inner square is extensionality.
Luckily, no \texttt{heq} is needed here, as the types are definitionally equal.
\[\begin{tikzcd}
	F & G && {\Sigma_p F\<X,p\>} &&& {\Sigma_p G\<X,p\>} \\
	X & {\< X , p \>} &&& {F\<X,p\>} & {G\<X,p\>} \\
	Y & {\< Y , p \>} &&& {F\<Y,p\>} & {G\<Y,p\>} \\
	&&& {\Sigma_p F\<Y,p\>} &&& {\Sigma_p G\<Y,p\>}
	\arrow["h"', from=2-1, to=3-1]
	\arrow["{\tilde{h}}"', from=2-2, to=3-2]
	\arrow["\alpha", from=1-1, to=1-2]
	\arrow["{(p,\alpha_X)}", from=1-4, to=1-7]
	\arrow["{(p,F \tilde{h})}"', from=1-4, to=4-4]
	\arrow["{(p,\alpha_Y)}"', from=4-4, to=4-7]
	\arrow["{(p,G \tilde{h})}", from=1-7, to=4-7]
	\arrow["{\alpha_X}", from=2-5, to=2-6]
	\arrow["{F \tilde{h}}"', from=2-5, to=3-5]
	\arrow["{\alpha_Y}"', from=3-5, to=3-6]
	\arrow["{G \tilde{h}}", from=2-6, to=3-6]
	\arrow[from=4-4, to=3-5]
	\arrow[from=1-4, to=2-5]
	\arrow[from=1-7, to=2-6]
	\arrow[from=4-7, to=3-6]
\end{tikzcd}\]

We finally turn this into a functor into the over category,
where each natural transformation down to $P$ is given by projection
onto the first component of the sigma type $\Sigma_{p} F \< X , p \>$ for each $X$.

\begin{lstlisting}
  def to_presheaf_over : (P.elements ⥤ Type u₀) ⥤ over P :=
  { obj := λ F, over.mk ({ app := λ X, sigma.fst } : to_presheaf_obj F ⟶ P),
    map := λ F G α, over.hom_mk (to_presheaf_map α) } \end{lstlisting}

\section{Backwards}

To make an inverse functor we fix a preseheaf $Q : \CC \to \UU$
with $\al : Q \implies P$,
and construct a presheaf on $\Sigma P$.
We first do so on objects, taking any object $\< X , p \> : \Sigma P$
to the pullback

\[\begin{tikzcd}
	{\alpha_X^{-1}p} & \star \\
	{Q X} & {P X}
	\arrow["p", from=1-2, to=2-2]
	\arrow[from=2-1, to=2-2]
	\arrow[from=1-1, to=1-2]
	\arrow[dashed, hook, from=1-1, to=2-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
\end{tikzcd}\]

Rather than using the abstract existence of pullbacks in \texttt{Type},
we construct it as the preimage of $p$ (as a subtype of $Q X$),
under $\alpha_{X}$.

\subsection{ On objects (\texttt{inverse}) }

\subsubsection{ On objects (\texttt{inverse\_obj}) }
\begin{lstlisting}
  def inverse_obj_obj : P.elements → Type u₀ :=
  λ ⟨ X , p ⟩, { q : Q.left.obj X // Q.hom.app X q = p } \end{lstlisting}

We extend this to a functor $\Sigma P \functor \UU$.
Suppose $pX : P X$ and $pY : P Y$.
Given a morphism $h : X \to Y$ in the category of elements by having a
commuting property $\texttt{hcomm}: P h pX = pY$,
the pullback property of $\al_{Y}^{-1} pY$ gives a map
from $\al_{X}^{-1} pX$, viewed as a cone over the diagram.
\[\begin{tikzcd}
	& {\alpha_X^{-1}pX} && \star \\
	& {Q X} && {P X} \\
	{\alpha_Y^{-1}pY} && \star \\
	{Q Y} && {P Y}
	\arrow[color={rgb,255:red,92;green,92;blue,214}, from=1-2, to=1-4]
	\arrow["pX"{description}, from=1-4, to=2-4]
	\arrow[color={rgb,255:red,214;green,92;blue,92}, from=1-2, to=2-2]
	\arrow["{\alpha_X}"{description, pos=0.7}, from=2-2, to=2-4]
	\arrow[dashed, from=1-2, to=3-1]
	\arrow["Qh"{description, pos=0.4}, color={rgb,255:red,214;green,92;blue,92}, from=2-2, to=4-1]
	\arrow[from=3-1, to=3-3]
	\arrow["{P h}"{description, pos=0.4}, from=2-4, to=4-3]
	\arrow["{\alpha_Y}"{description, pos=0.7}, color={rgb,255:red,214;green,92;blue,92}, from=4-1, to=4-3]
	\arrow[from=3-1, to=4-1]
	\arrow[color={rgb,255:red,92;green,92;blue,214}, from=1-4, to=3-3]
	\arrow["pY"{description}, color={rgb,255:red,92;green,92;blue,214}, from=3-3, to=4-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=3-1, to=4-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-2, to=2-4]
\end{tikzcd}\]
In our construction we explicitely give the induced morphism,
which is as the ``restriction of $Q h$ to $\al_{X}^{-1} pX$'',
consisting of the map $Q h$ on elements and a proof that the image is sent to
$pY$.
The image is sent to $pY$ if and only if the blue and red maps
(the legs of the pullback cone) commute.
The latter holds because the right face commutes by \texttt{homm},
the back face commutes by the pullback property defining $\al_{X}^{-1}pX$
(in the proof this appears as \texttt{hqX}),
and the bottom face commutes by naturality of $\alpha$.

\subsubsection{ Functoriality (\texttt{inverse\_obj})}

\begin{lstlisting}
  def inverse_obj_map : Π (X Y : P.elements) (h : X ⟶ Y),
    inverse_obj_obj Q X ⟶ inverse_obj_obj Q Y :=
  λ ⟨ X , pX ⟩ ⟨ Y , pY ⟩ ⟨ h , hcomm ⟩ ⟨ qX , hqX ⟩,
    ⟨ Q.left.map h qX , by { convert hcomm, rw ← hqX, exact congr_fun (Q.hom.naturality h) qX } ⟩ \end{lstlisting}

Again, \texttt{obviously} cannot generate code for this functor preserving
the identity and composition.
This time it is because we need to use functional extensionality and case
on the points in the sigma type, which is straight forward.

\begin{lstlisting}
def inverse_obj : P.elements ⥤ Type u₀ :=
{ obj := inverse_obj_obj Q,
  map := λ _ _, inverse_obj_map Q _ _,
  map_id' := λ ⟨ X , p ⟩, funext $ λ ⟨ q , hq ⟩, by { simp ... },
  map_comp' := λ ⟨ X , pX ⟩ ⟨ Y , pY ⟩ ⟨ Z , pZ ⟩ ⟨ f , fcomm ⟩ ⟨ g , gcomm ⟩,
    funext $ λ ⟨ qX , hqX ⟩, by { simp ... }\end{lstlisting}

\subsection{ Functoriality \texttt{inverse} }

We need to construct for each natural transformation $\nu : Q_{0} \implies Q_{1}$
of presheaves over the presheaf $P$, a natural transformation
\texttt{inverse\_obj $Q_0 \implies $ inverse\_obj $Q_{1}$}.
To make such a natural transformation,
we need a map for each object $\< X , p \> : \Sigma P$,
\begin{lstlisting}
  { q : Q₀.left.obj X // Q₀.hom.app X q = p } ⟶ { q : Q₁.left.obj X // Q₁.hom.app X q = p }
\end{lstlisting}
which we write as
\[ \al_{0}^{-1}(p) \to \al_{1}^{-1}(p)\]
Via pullbacks it is given by the universal property of $\al_{1}^{-1}(p)$
in the following diagram:
\[\begin{tikzcd}
	& {\alpha_0^{-1}p} && \star \\
	& {Q_0 X} && {P X} \\
	{\alpha_1^{-1}p} && \star \\
	{Q_1 X} && {P X}
	\arrow[color={rgb,255:red,92;green,92;blue,214}, from=1-2, to=1-4]
	\arrow["p"{description}, from=1-4, to=2-4]
	\arrow[color={rgb,255:red,214;green,92;blue,92}, from=1-2, to=2-2]
	\arrow["{\alpha_0}"{description, pos=0.7}, from=2-2, to=2-4]
	\arrow[dashed, from=1-2, to=3-1]
	\arrow["Qh"{description, pos=0.4}, color={rgb,255:red,214;green,92;blue,92}, from=2-2, to=4-1]
	\arrow[from=3-1, to=3-3]
	\arrow["{\id{}{}}"{description, pos=0.4}, from=2-4, to=4-3]
	\arrow["{\alpha_1}"{description, pos=0.7}, color={rgb,255:red,214;green,92;blue,92}, from=4-1, to=4-3]
	\arrow[from=3-1, to=4-1]
	\arrow[color={rgb,255:red,92;green,92;blue,214}, from=1-4, to=3-3]
	\arrow["p"{description}, color={rgb,255:red,92;green,92;blue,214}, from=3-3, to=4-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=3-1, to=4-3]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-2, to=2-4]
\end{tikzcd}\]
As before it suffices that the right, back, and bottom sides commute,
which respectively
hold trivially, by the pullback property of $\al_{0}^{-1}(p)$, and
by $\nu$ being a morphism in the over category (\texttt{$\nu$.w} in the code).

\begin{lstlisting}
  def inverse : over P ⥤ P.elements ⥤ Type u₀ :=
  { obj := inverse_obj,
    map := λ Q₀ Q₁ ν,
      { app := λ ⟨ X , p ⟩ ⟨ q , hq ⟩, ⟨ ν.left.app X q ,
          by {convert hq, exact congr_fun (congr_fun (congr_arg nat_trans.app ν.w) X) q } ⟩,
        naturality' := λ ⟨ X , pY ⟩ ⟨ Y , pY ⟩ ⟨ h , hcomm ⟩, funext ( λ ⟨ q , hq ⟩,
        subtype.ext (congr_fun (ν.left.naturality h) q)) } } \end{lstlisting}

Naturality requires \texttt{funext} and \texttt{subtype.ext},
but otherwise follows from naturality of $\nu$.

\section{Left and right inverses}

It remains show that the composed functors back and forth are naturally
isomorphic to the identity functors.
Here \texttt{obtain} is able to bear a lot of the workload.

Our first goal is to show that the identity functor on the presheaf
category on $\Sigma P$ is naturally isomorphic to the composition.
This involves making natural transformations back and forth,
both of which are also natural transformations on objects.
These maps are easy to define once we case on the objects;
though the goals are unsightly,
by going tactic mode and using \texttt{dsimp} they become very simple,
so that is the recommended first approach to making these definitions.

\begin{lstlisting}
  def unit_iso_hom : 𝟭 (P.elements ⥤ Type u₀) ⟶ to_presheaf_over ⋙ inverse :=
  { app := λ F, { app := λ ⟨ X , p ⟩ f, ⟨ ⟨ p , f ⟩ , rfl ⟩ } }

  def unit_iso_inv : to_presheaf_over ⋙ inverse ⟶ 𝟭 (P.elements ⥤ Type u₀) :=
  { app := λ F, { app := λ ⟨ X , p ⟩ ⟨ ⟨ p' , f ⟩ , hq ⟩, eq.mp (by {congr, exact hq}) f }}

  def unit_iso : 𝟭 (P.elements ⥤ Type u₀) ≅ to_presheaf_over ⋙ inverse :=
  { hom := unit_iso_hom,
    inv := unit_iso_inv } \end{lstlisting}

Note that \texttt{obtain} worked out all the naturality conditions needed.
For the other direction we make use of \texttt{ext} whereever possible,
and note that in the cases of extensionality on sigma types no \texttt{heq}
is needed. Again, nothing interesting is going on here so we omit the code.

\bibliography{refs}{}
\bibliographystyle{abbrv}

\end{document}
