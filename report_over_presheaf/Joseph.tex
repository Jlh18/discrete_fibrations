\documentclass{article}
\usepackage[left=1in,right=1in,tmargin = 25mm,bmargin = 25mm]{geometry}
\usepackage[left=1in,right=1in]{geometry}
\usepackage{subfiles}
\usepackage{amsmath, amssymb, stmaryrd, verbatim, bbm, mathabx} % math symbols
\usepackage{amsthm} % thm environment
\usepackage{mdframed} % Customizable Boxes
\usepackage{hyperref,nameref,cleveref,enumitem} % for references, hyperlinks
\usepackage[dvipsnames]{xcolor} % Fancy Colours
\usepackage{mathrsfs} % Fancy font
\usepackage{tikz, tikz-cd, float} % Commutative Diagrams
\usepackage{perpage}
\usepackage{parskip} % So that paragraphs look nice
\usepackage{ifthen,xargs} % For defining better commands
\usepackage{anyfontsize}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage{titlesec}
\usepackage{url}
\usepackage{listings}

% local

\DeclareMathOperator{\PSh}{Psh}
\newcommand{\functor}{\rightrightharpoons}

% % Misc
\newcommand{\brkt}[1]{\left(#1\right)}
\newcommand{\sqbrkt}[1]{\left[#1\right]}
\newcommand{\dash}{\text{-}}
\newcommand{\tdt}{\times \dots \times}

% % Logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\limplies}{\Leftarrow}
\newcommand{\NOT}{\neg\,}
\newcommand{\AND}{\land}
\newcommand{\OR}{\lor}
\newenvironment{forward}{($\implies$)}{}
\newenvironment{backward}{($\limplies$)}{}
% General way of making larger symbols with limits above and below
\makeatletter
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{
      \ifx#1\displaystyle.7\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}% symbol size
  }%
}
\makeatother
\newcommand{\bigforall}[2]{\DOTSB\bigop{\forall}_{#1}^{#2}}
\newcommand{\bigexists}[2]{\DOTSB\bigop{\exists}_{#1}^{#2}}
\newcommand{\bigand}[2]{\DOTSB\bigop{\mbox{\Large$\land$}}_{#1}^{#2}}
\newcommand{\bigor}[2]{\DOTSB\bigop{\mbox{\Large$\lor$}}_{#1}^{#2}}

% % Sets
\DeclareMathOperator{\supp}{supp}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\st}{\,|\,}
\newcommand{\minus}{\setminus}
\newcommand{\subs}{\subseteq}
\newcommand{\ssubs}{\subsetneq}
\DeclareMathOperator{\im}{Im}
\newcommand{\nothing}{\varnothing}
\newcommand\res[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace
  % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|}
  % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

% % Greek
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\varepsilon}
\newcommand{\io}{\iota}
\newcommand{\ka}{\kappa}
\newcommand{\la}{\lambda}
\newcommand{\om}{\omega}
\newcommand{\si}{\sigma}

\newcommand{\Ga}{\Gamma}
\newcommand{\De}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\La}{\Lambda}
\newcommand{\Si}{\Sigma}
\newcommand{\Om}{\Omega}

% % Mathbb
\newcommand{\A}{\mathbb{A}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\U}{\mathbb{U}}

% % Mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\II}{\mathcal{I}}
\newcommand{\JJ}{\mathcal{J}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\newcommand{\RR}{\mathcal{R}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YY}{\mathcal{Y}}
\newcommand{\ZZ}{\mathcal{Z}}

% % Mathfrak
\newcommand{\f}[1]{\mathfrak{#1}}

% % Mathrsfs
\newcommand{\s}[1]{\mathscr{#1}}

% % Category Theory
\newcommand{\obj}[1]{\mathrm{Obj}\left(#1\right)}
\newcommand{\Hom}[3]{\mathrm{Hom}_{#3}(#1, #2)\,}
\newcommand{\mor}[3]{\mathrm{Mor}_{#3}(#1, #2)\,}
\newcommand{\End}[2]{\mathrm{End}_{#2}#1\,}
\newcommand{\aut}[2]{\mathrm{Aut}_{#2}#1\,}
\newcommand{\CAT}{\mathbf{Cat}}
\newcommand{\SET}{\mathbf{Set}}
\newcommand{\TOP}{\mathbf{Top}}
%\newcommand{\GRP}{\mathbf{Grp}}
\newcommand{\RING}{\mathbf{Ring}}
\newcommand{\MOD}[1][R]{#1\text{-}\mathbf{Mod}}
\newcommand{\VEC}[1][K]{#1\text{-}\mathbf{Vec}}
\newcommand{\ALG}[1][R]{#1\text{-}\mathbf{Alg}}
\newcommand{\PSH}[1]{\mathbf{PSh}\brkt{#1}}
\newcommand{\map}[2]{ \yrightarrow[#2][2.5pt]{#1}[-1pt] }
\newcommand{\op}{^{op}}
\newcommand{\darrow}{\downarrow}
\newcommand{\LIM}[2]{\varprojlim_{#2}#1}
\newcommand{\COLIM}[2]{\varinjlim_{#2}#1}
\newcommand{\hookr}{\hookrightarrow}

% % Algebra
\newcommand{\iso}{\cong}
\newcommand{\nsub}{\trianglelefteq}
\newcommand{\id}[1]{\mathbbm{1}_{#1}}
\newcommand{\inv}{^{-1}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}
\DeclareMathOperator{\coker}{Coker}
\DeclareMathOperator{\spec}{Spec}

% % Analysis
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\renewcommand{\check}[1]{\widecheck{#1}}

% % Galois
\newcommand{\Gal}[2]{\mathrm{Gal}_{#1}(#2)}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}
\newcommand{\emb}[3]{\mathrm{Emb}_{#1}(#2, #3)}
\newcommand{\Char}[1]{\mathrm{Char}#1}

% % Model Theory
\newcommand{\intp}[2]{
    \star_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\subintp}[3]{
    {#3}_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\modintp}[2]{#2^\text{\scalebox{0.7}{$#1$}}}
\newcommand{\mmintp}[1]{\modintp{\MM}{#1}}
\newcommand{\nnintp}[1]{\modintp{\NN}{#1}}
\DeclareMathOperator{\const}{constants}
\DeclareMathOperator{\func}{functions}
\DeclareMathOperator{\rel}{relations}
% \newcommand{\term}[1]{{#1}_\mathrm{ter}}
% \newcommand{\tv}[1]{\textrm{tv}_{#1}}
% \newcommand{\struc}[1]{\mathbf{Str}(#1)}
% \newcommand{\form}[1]{{#1}_\mathrm{for}}
% \newcommand{\var}[1]{{#1}_\mathrm{var}}
% \newcommand{\theory}[1]{{#1}_\mathrm{the}}
% \newcommand{\carrier}[1]{{#1}_\mathrm{car}}
% \newcommand{\model}[1]{\vDash_{#1}}
% \newcommand{\nodel}[1]{\nvDash_{#1}}
% \newcommand{\modelsi}{\model{\Si}}
% \newcommand{\nodelsi}{\nvDash_{\Si}}
% \newcommand{\eldiag}[2]{\mathrm{ElDiag}(#1,#2)}
% \newcommand{\atdiag}[2]{\mathrm{AtDiag}(#1,#2)}
% \newcommand{\Theory}{\mathrm{Th}}
% \newcommand{\unisen}[1]{{#1}_\mathrm{uni}}
\newcommand{\lift}[2]{\uparrow_{#1}^{#2}}
\newcommand{\fall}[2]{\downarrow_{#1}^{#2}}
\DeclareMathOperator{\GRP}{GRP}
\newcommand{\RNG}{\mathrm{RNG}}
\newcommand{\ER}{\mathrm{ER}}
\DeclareMathOperator{\FLD}{FLD}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\ZFC}{ZFC}
\DeclareMathOperator{\ACF}{ACF}
\newcommand{\BLN}{\mathrm{BLN}}
\newcommand{\PO}{\mathrm{PO}}
\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\qftp}{qftp}
\DeclareMathOperator{\qf}{qf}
\DeclareMathOperator{\eqzero}{eqzero}
\newcommand{\MR}[2]{\mathrm{MR}^{#1}(#2)}
\DeclareMathOperator{\MD}{MD}
\DeclareMathOperator{\acl}{acl}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\mdeg}{m.deg}
\DeclareMathOperator{\kdim}{k.dim}
\newcommand{\Mod}[1]{EDITTHIS {#1}}
% % Set theory
\DeclareMathOperator{\ord}{Ord}

% % Boolean algebra
\newcommand{\NEG}{\smallsetminus}
\newcommand{\upa}[1]{#1^{\uparrow}}

% % Field theory
\DeclareMathOperator{\tdeg}{t.deg}
\newcommand{\zmo}[2][p]{\Z/#1^{#2}\Z}

%% code from mathabx.sty and mathabx.dcl to get some symbols from mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}

% Arrows with text above and below with adjustable displacement
% (Stolen from Stackexchange)
\newcommandx{\yaHelper}[2][1=\empty]{
\ifthenelse{\equal{#1}{\empty}}
  % no offset
  { \ensuremath{ \scriptstyle{ #2 } } }
  % with offset
  { \raisebox{ #1 }[0pt][0pt]{ \ensuremath{ \scriptstyle{ #2 } } } }
}

\newcommandx{\yrightarrow}[4][1=\empty, 2=\empty, 4=\empty, usedefault=@]{
  \ifthenelse{\equal{#2}{\empty}}
  % there's no text below
  { \xrightarrow{ \protect{ \yaHelper[ #4 ]{ #3 } } } }
  % there's text below
  {
    \xrightarrow[ \protect{ \yaHelper[ #2 ]{ #1 } } ]
    { \protect{ \yaHelper[ #4 ]{ #3 } } }
  }
}

% xcolor
\definecolor{darkgrey}{gray}{0.10}
\definecolor{lightgrey}{gray}{0.30}
\definecolor{slightgrey}{gray}{0.80}
\definecolor{softblue}{RGB}{30,100,200}

% hyperref
\hypersetup{
      colorlinks = true,
      linkcolor = {softblue},
      citecolor = {blue}
}

\newcommand{\link}[1]{\hypertarget{#1}{}}
\newcommand{\linkto}[2]{\hyperlink{#1}{#2}}

% Theorems

% % custom theoremstyles
\newtheoremstyle{definitionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % custom theoremstyles
\newtheoremstyle{propositionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

\newtheoremstyle{exercisestyle}%
{0pt}% above thm
{0pt}% below thm
{\it}% body font
{}% space to indent
{\scshape}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{ (#3)}}

\newtheoremstyle{remarkstyle}%
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\it}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % Theorem environments

\theoremstyle{definitionstyle}
\newmdtheoremenv[
    %skipabove = \baselineskip
    linewidth = 2pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{dfn}{Definition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{prop}{Proposition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{cor}{Corollary}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{lem}{Lemma}


\theoremstyle{exercisestyle}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{ex}{Exercise}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{eg}{Example}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{nttn}{Notation}

\theoremstyle{remarkstyle}
\newtheorem{rmk}{Remark}

% % footnotes
\renewcommand{\thempfootnote}{$\dagger$}
\MakePerPage{footnote}

% % tikzcd diagram
\newenvironment{cd}{
    \begin{figure}[H]
    \centering
    \begin{tikzcd}
}{
    \end{tikzcd}
    \end{figure}
}

% tikzcd
% % Substituting symbols for arrows in tikz comm-diagrams.
\tikzset{
  symbol/.style={
    draw=none,
    every to/.append style={
      edge node={node [sloped, allow upside down, auto=false]{$#1$}}}
  }
}


\titlespacing*{\section}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}

% Syntax highlighting for lean

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.6, 0.3, 0.6}   % light purple
\definecolor{tacticcolor}{rgb}{0.2, 0.2, 0.6}    % dark purple
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.7, 0.2, 0.2}    % blue
\definecolor{sortcolor}{rgb}{0.2, 0.7, 0.7}      % cyan
\definecolor{attributecolor}{RGB}{120,0,0}       % maroon
\definecolor{draculaGrey}{RGB}{25, 27, 15}       % grey

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\begin{document}
\title{Presheaves over the category of elements of a presheaf}
\author{Joseph Hua}
\maketitle

\section{Conventions}

We call functors $P : \CC \functor \UU$ for some universe $\UU$
a presheaf, although the convention is usually dual, with $\CC^{\op}$ instead.
Since the proofs work exactly the same for the dual case, this is justified.

\section{The goal}

In the file \texttt{over\_presheaf.lean} we prove a category-theoretic lemma
that says if $P : \CC \functor \UU$ is a presheaf on category $\CC$ then
the category of presheaves over the category of elements of $P$ is equivalent
to the over category of $P$.
\[ \PSh(\Sigma P) \iso \PSh(C) / P \]
In lean this is stated as

\begin{lstlisting}
  def equivalence : (P.elements ⥤ Type u₀) ≅ over P :=
  { functor := _,
    inverse := _,
    iso := _,
    counit_iso := _ } \end{lstlisting}

Since presheaves on a category $\CC$ is defined as the functors
from $\CC$ into the universe, which in type theory is taken to be
\texttt{Type u}$_{0}$ for some universe level $u_{0}$.
There are four\footnote{There is an extra one, the ``triangle law'',
  but it is automatically generated by \texttt{obviously} in this case.}
fields required to define an equivalence of
categories: the functors forwards and back, and proof that they are left and
right inverses.

The idea is that a presheaf on $\CC$ takes any object $X : \CC$ to
the set of generalized elements of $X$, which are points
$p : \star \to P X$ ($\star : \UU$ is the terminal object in the universe).
Then a presheaf $F$ on $\Sigma P$ takes any object
$\< X : \CC , p : P X \>$ in the category of elements of $P$ to a
generalized elements of $X$ that commute with $p$,
forming points $f : \star \to F\< X , p \>$.
\[\begin{tikzcd}
	\star & F\<X,p\> \\
        & P X
	\arrow["f", from=1-1, to=1-2]
	\arrow["p"', from=1-1, to=2-2]
	\arrow[from=1-2, to=2-2]
\end{tikzcd}\]
If we collect these generalized elements under $F$
across all $p : \star \to X$ then we can get a map
$\Sigma_{p : \star \to X} F\< X , p \> \to P X$
with each $F\< X , p \>$ the fiber of a point $p$.

\[\begin{tikzcd}
	\star & \Sigma_{p} F\<X,p\> \\
        & P X
	\arrow["\<p . f\>", from=1-1, to=1-2]
	\arrow["p"', from=1-1, to=2-2]
	\arrow[two heads, from=1-2, to=2-2]
\end{tikzcd}\]

Thus to make a functor forward, we take a functor $F : \PSh(\Sigma P) \to \UU$
and make a presheaf by
\[ (X : \CC) \mapsto \Sigma_{p : \star \to X} F \< X , p \> : \UU \]
It is in the over category of $P$ since we have a map down to each generalized set $P X$
with fibers $F \< X , p \>$.

To make an inverse, we take a presheaf $Q : \CC \functor \UU$ over $P$,
meaning we have a natural transformation $\al : Q \implies P$,
and produce a presheaf on $\Sigma P$ by taking an object $\< X,p \> : \Sigma P$
and picking out the generalized elements of $X$ under $Q$
that commute with $p$.
This is the pullback
\[\begin{tikzcd}
	{\alpha_X^{-1}p} & \star \\
	{Q X} & {P X}
	\arrow["p", from=1-2, to=2-2]
	\arrow[from=2-1, to=2-2]
	\arrow[from=1-1, to=1-2]
	\arrow[dashed, hook, from=1-1, to=2-1]
	\arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
\end{tikzcd}\]

\section{Forwards}

To construct the functor forwards, we must functorially construct for each
functor \texttt{F : P.elements $\functor$ Type u}$_{0}$ an object of the
over category \texttt{over P}.
An object of the over category \texttt{over P} consists of a presheaf
\texttt{to\_presheaf\_obj F : C $\functor$ Type u}$_{0}$
and a natural transformation down to \texttt{P}.
As described above, we define the presheaf part by taking the sum
of generalized elements from $F$

\begin{lstlisting}
def to_presheaf_obj : C ⥤ Type u₀ :=
{ obj := λ X, Σ p : P.obj X, F.obj ⟨ X , p ⟩,
  map := λ X Y h, λ ⟨ p , f ⟩, ⟨ P.map h p , F.map (hom_mk h rfl) f ⟩,
  map_id' := _,
  map_comp' := _ } \end{lstlisting}

For mapping morphisms, the obvious thing to do is to send the point $p$
along by the image under $P$ of the morphism $h$,
and send $f$ along the image under $F$ of the morphism
in the category of elements induced by $h$.

\subsection{\texttt{obj\_mk} and \texttt{hom\_mk}}
To expain \texttt{hom\_mk}:
For design purposes, it is convenient to make functions \texttt{obj\_mk}
and \texttt{hom\_mk} that produce objects and morphisms in the category
of elements of $P$\footnote{We could use brackets $\<\_,\_\>$
  and provide the type each time, but this is harder on the eyes. };
objects are given by objects $X : \CC$ and generalized elements $p : P X$
and morphisms are given by morphisms $h : X \to Y$ and proofs that
$h$ respects the points in $X$ and $Y$.

\begin{lstlisting}
/-- Explicit, typed construction of an object in category of elements -/
def obj_mk (X : C) (p : P.obj X) : P.elements := ⟨ X , p ⟩

/-- Explicit, typed construction of a hom in category of elements -/
def hom_mk {X Y : C} {pX : P.obj X} {pY : P.obj Y} (h : X ⟶ Y) (hcomm : P.map h pX = pY) :
  obj_mk X pX ⟶ obj_mk Y pY := ⟨ h , hcomm ⟩\end{lstlisting}

\subsection{\texttt{heq} issues}
Above we gave the data of what the presheaf on $\CC$ does,
but \texttt{obviously} is not able to show that this respects the identity
and composition, because there are definitional equality issues.
For the identity we let $X : \CC$ be an object and consider whether
we are sending the identity on $X$ to the identity on the sigma type.
The problem is, the image of the identity is the function
\begin{lstlisting}
  λ ⟨ p , f ⟩, ⟨ P.map (𝟙 X) p , F.map (hom_mk (𝟙 X) rfl) f ⟩ \end{lstlisting}
where the second component has type
\begin{lstlisting}
  F.obj ⟨ X , P.map (𝟙 X) p ⟩ \end{lstlisting}
whereas the identity on the image will have second component
\begin{lstlisting}
  f : F.obj ⟨ X , p ⟩ \end{lstlisting}
It makes sense to ask if the functions are equal,
but to prove this we must use functional extensionality,
introducing such a pair $\< p , f \>$.
It makes sense to ask if their images are equal as terms in the sigma type,
\begin{lstlisting}
  Σ p : P.obj X, F.obj ⟨ X , p ⟩ \end{lstlisting}
but to prove this we must use extensionality on the sigma type,
which introduces \texttt{heq}, since the types on the second part are not
definitionally equal.
Hence the proof goes
\begin{lstlisting}
def to_presheaf_obj : C ⥤ Type u₀ :=
{ obj := ...,
  map := ...,
  map_id' := λ X, funext (λ ⟨ p , f ⟩,
    by { ext, { simp [to_presheaf_obj._match_1] }, ??? }),
    map_comp' := ...} \end{lstlisting}
The first goal is a true equality and can be closed by simplifying
until both sides are just $p$.
The second goal (currently \texttt{???}) is the
\texttt{heq}uality and needs care.
The goal reduces to asking for a proof that
\begin{lstlisting}
  F.map (hom_mk (𝟙 X) rfl) f == f \end{lstlisting}
We hope that we can use transitivity of \texttt{heq} to break this up into
\begin{lstlisting}
  F.map (hom_mk (𝟙 X) rfl) f == F.map (𝟙 ⟨X, p⟩) f == f \end{lstlisting}
Where the last \texttt{heq}uality is a definitional equality,
and is true since functor $F$ preserves the identity.
The first equality naively looks like two applications of \texttt{congr},
but for \texttt{heq}.
Indeed we make such a lemma

\begin{lstlisting}
  lemma hcongr_fun {f₀ : α → β₀} {f₁ : α → β₁} (hβ : β₀ = β₁) (hf : f₀ == f₁) (a : α) :
    f₀ a == f₁ a := by { subst hβ, subst hf } \end{lstlisting}

Applying the above removes $f$, reducing the goal to
\begin{lstlisting}
  F.map (hom_mk (𝟙 X) rfl) == F.map (𝟙 ⟨X, p⟩) \end{lstlisting}
This is surprisingly straight forward
\begin{lstlisting}
  lemma map_hom_mk_id_heq_map_id {X : C} {p : P.obj X} {F : P.elements ⥤ Type u₀} :
    F.map (hom_mk (𝟙 X) rfl) == F.map (𝟙 ⟨ X , p ⟩) :=
  by { congr', {simp}, {simp} } \end{lstlisting}

\subsection{The rest of the functor}

The story for \texttt{map\_comp'} is similar, and not worth examining in detail.
To summarize,
the above gave us a presheaf on $\CC$ for each presheaf on $\Sigma P$.
We want to make this construction a functor, rather than just a function.
So we also define a function on maps (natural transformations in our case
since the objects are functors)

\begin{lstlisting}
  def to_presheaf_map (α : F ⟶ G) : to_presheaf_obj F ⟶ to_presheaf_obj G :=
  { app := λ X ⟨ p , f ⟩, ⟨ p , α.app _ f ⟩,
    naturality' := λ X Y h, funext (λ ⟨ p , f ⟩, by { ext,
      { simp [to_presheaf_map._match_1, to_presheaf_obj] },
      { apply heq_of_eq, exact congr_fun
        (@nat_trans.naturality _ _ _ _ _ _ α ⟨ X , p ⟩ ⟨ Y , P.map h p ⟩ ⟨ h , rfl ⟩) f }})} \end{lstlisting}

The natural transformation at each object $X : \CC$ is
given extensionally as a map between sigma types such that for each
generalized element $p$ of $X$ under $P$, the diagram commutes
\[\begin{tikzcd}
	{F \< X , p \>} & {G\<X,p\>} \\
	\bullet & PX
	\arrow["{\alpha _X}", from=1-1, to=1-2]
	\arrow["f", from=2-1, to=1-1]
	\arrow["p"', from=2-1, to=2-2]
	\arrow[from=1-2, to=2-2]
	\arrow[from=1-1, to=2-2]
	\arrow[dashed, from=2-1, to=1-2]
\end{tikzcd}\]
Since this map is defined component-wise,
we use extensionality on the sigma type to check naturality,
and it follows from naturality of $\al$,
i.e. the outer square commutes because each inner square commutes,
where going to the inner square is extensionality.
\[\begin{tikzcd}
	F & G && {\Sigma_p F\<X,p\>} &&& {\Sigma_p G\<X,p\>} \\
	X & {\< X , p \>} &&& {F\<X,p\>} & {G\<X,p\>} \\
	Y & {\< Y , p \>} &&& {F\<Y,p\>} & {G\<Y,p\>} \\
	&&& {\Sigma_p F\<Y,p\>} &&& {\Sigma_p G\<Y,p\>}
	\arrow["h"', from=2-1, to=3-1]
	\arrow["{\tilde{h}}"', from=2-2, to=3-2]
	\arrow["\alpha", from=1-1, to=1-2]
	\arrow["{(p,\alpha_X)}", from=1-4, to=1-7]
	\arrow["{(p,F \tilde{h})}"', from=1-4, to=4-4]
	\arrow["{(p,\alpha_Y)}"', from=4-4, to=4-7]
	\arrow["{(p,G \tilde{h})}", from=1-7, to=4-7]
	\arrow["{\alpha_X}", from=2-5, to=2-6]
	\arrow["{F \tilde{h}}"', from=2-5, to=3-5]
	\arrow["{\alpha_Y}"', from=3-5, to=3-6]
	\arrow["{G \tilde{h}}", from=2-6, to=3-6]
	\arrow[from=4-4, to=3-5]
	\arrow[from=1-4, to=2-5]
	\arrow[from=1-7, to=2-6]
	\arrow[from=4-7, to=3-6]
\end{tikzcd}\]

We finally turn this into a functor into the over category,
where the maps down to $P$ are projections onto the first component
of the sigma type $\Sigma_{p} F \< X , p \>$ for each $X$.

\begin{lstlisting}
def to_presheaf_over : (P.elements ⥤ Type u₀) ⥤ over P :=
{ obj := λ F, over.mk ({ app := λ X, sigma.fst } : to_presheaf_obj F ⟶ P),
  map := λ F G α, over.hom_mk (to_presheaf_map α) } \end{lstlisting}

\section{Backwards}

\bibliography{refs}{}
\bibliographystyle{abbrv}

\end{document}
